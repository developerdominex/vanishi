<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hybrid â€” Chat</title>
<link rel="icon" href="hybrid.png" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<style>
:root{
  --bg:#e6eefc;
  --side:#ffffff;
  --card:#ffffff;
  --primary:#2b9cff;
  --primary-600:#257ed6;
  --muted:#6b7280;
  --shadow:0 12px 30px rgba(16,24,40,0.08);
  --radius:14px;
}

*{box-sizing:border-box;margin:0;padding:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,'Helvetica Neue',Arial;}
html,body{height:100%;}
body{
  background: linear-gradient(180deg, #f6fbff 0%, #e6eefc 100%);
  display:flex;align-items:center;justify-content:center;height:100vh;overflow:hidden;
  padding:24px;
}
.app {
  width:100%;
  max-width:1100px;
  height:100%;
  max-height:800px;
  background:transparent;
  display:grid;
  grid-template-columns: 320px 1fr;
  gap:20px;
  align-items:stretch;
}

.panel {
  background:var(--side);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  overflow:hidden;
  display:flex;
  flex-direction:column;
}

.panel .header {
  padding:18px 16px;
  display:flex;
  align-items:center;
  gap:12px;
  border-bottom:1px solid rgba(15,23,42,0.04);
}
.panel .header .title{
  font-weight:700;color:#0f172a;
  font-size:16px;
}
.panel .header .subtitle{
  color:var(--muted);font-size:12px;margin-top:4px;
}

.search {
  padding:12px 14px;border-bottom:1px solid rgba(15,23,42,0.04);
  display:flex;gap:8px;align-items:center;
}
.search input{
  flex:1;border-radius:12px;padding:10px 12px;border:1px solid rgba(15,23,42,0.06);
  outline:none;background:#fbfdff;font-size:14px;color:#071133;
  transition:box-shadow .18s ease;
}
.search input:focus{box-shadow:0 6px 18px rgba(43,156,255,0.12);border-color:var(--primary-600);}

.list {
  padding:12px;
  flex:1;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.contact {
  display:flex;align-items:center;gap:12px;padding:10px;border-radius:12px;cursor:pointer;
  transition:background .12s ease, transform .12s ease;
}
.contact:hover{ background:rgba(43,156,255,0.04); transform:translateY(-2px);}
.contact.selected{ background:linear-gradient(90deg,var(--primary) 0%, var(--primary-600) 100%); color:white; box-shadow:0 10px 30px rgba(43,156,255,0.12); }
.avatar{ width:48px;height:48px;border-radius:50%;flex-shrink:0;object-fit:cover;box-shadow:0 6px 18px rgba(2,6,23,0.06); }
.meta{ display:flex;flex-direction:column; gap:4px; min-width:0; }
.meta .name{ font-weight:600; font-size:15px; color:#071133; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.contact.selected .name{ color:white; }
.meta .last{ color:var(--muted); font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.contact.selected .last{ color:rgba(255,255,255,0.9); }

.chat {
  background:linear-gradient(180deg,#ffffff, #f7fbff);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  overflow:hidden;display:flex;flex-direction:column;
}

.chat .top {
  padding:14px 18px;display:flex;align-items:center;gap:12px;border-bottom:1px solid rgba(15,23,42,0.04);
}
.chat .top img{ width:44px;height:44px;border-radius:50%;object-fit:cover; display:block; }
.chat .top .who{ display:flex;flex-direction:column;}
.chat .top .who .n{ font-weight:700; color:#071133; }
.chat .top .who .s{ font-size:13px;color:var(--muted); }

.chat .body {
  padding:20px; flex:1; overflow:auto; display:flex; flex-direction:column; gap:10px; background:linear-gradient(180deg,#f7fbff00,#ffffff00);
}
.messages{ display:flex; flex-direction:column; gap:8px; width:100%; max-width:820px; margin-top:auto; margin-bottom:auto;}
.msg {
  display:inline-block; max-width:72%; padding:12px 14px; border-radius:18px; font-size:15px; line-height:1.3;
  box-shadow:0 6px 20px rgba(2,6,23,0.06); opacity:0; transform:translateY(8px);
  animation:pop .22s ease forwards;
}
@keyframes pop{ to{ opacity:1; transform:none; } }
.msg.me{ background:linear-gradient(180deg,var(--primary),var(--primary-600)); color:white; align-self:flex-end; border-bottom-right-radius:6px;}
.msg.other{ background:#fff; color:#071133; align-self:flex-start; border-bottom-left-radius:6px;}
.msg img{ max-width:300px;border-radius:12px; display:block; }
.time{ font-size:11px;color:var(--muted); margin-top:6px; opacity:0.9;}

.composer {
  padding:12px; border-top:1px solid rgba(15,23,42,0.04); display:flex; gap:8px; align-items:center; background:linear-gradient(180deg, #ffffff, #f7fbff);
}
.input {
  flex:1; background:#f3f6ff; padding:10px 14px; border-radius:999px; display:flex; gap:8px; align-items:center;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.6);
}
.input input{ flex:1; border:none; background:transparent; outline:none; font-size:15px; color:#071133;}
.icon-btn{ width:44px; height:44px; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; border:none; background:transparent; color:var(--primary); font-size:18px; }
.send{ width:48px;height:44px;border-radius:12px; display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--primary),var(--primary-600)); color:white; font-size:18px; border:none; cursor:pointer; box-shadow:0 10px 24px rgba(43,156,255,0.14); }

.placeholder{
  display:flex; align-items:center; justify-content:center; color:var(--muted); font-size:15px;
}

@media (max-width:900px){
  .app{ grid-template-columns: 1fr; gap:12px; align-items:stretch; max-width:720px; padding:12px; }
  .panel{ order:2; height:38vh; border-radius:12px; }
  .chat{ order:1; height:60vh; border-radius:12px; }
}
</style>
</head>
<body>

<div class="app" id="app">
  <div class="panel" id="sidebar">
    <div class="header">
      <div style="display:flex;flex-direction:column">
        <div class="title">Hybrid</div>
        <div class="subtitle">messaging</div>
      </div>
    </div>

    <div class="search">
      <input id="search" placeholder="Search people or paste id..." autocomplete="off">
      <button class="icon-btn" id="addBtn" title="Add by ID"><i class="fas fa-user-plus"></i></button>
    </div>

    <div class="list" id="contacts"></div>
    <div style="padding:12px;border-top:1px dashed rgba(15,23,42,0.04);display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div style="display:flex;gap:8px;align-items:center">
        <img id="myAvatar" src="" style="width:42px;height:42px;border-radius:50%;object-fit:cover">
        <div style="font-size:13px;color:#071133;font-weight:600" id="myName"></div>
      </div>
      <button id="logout" class="icon-btn" style="background:#fff;color:#ef4444;border-radius:10px;"><i class="fas fa-right-from-bracket"></i></button>
    </div>
  </div>

  <div class="chat" id="chat">
    <div class="top">
      <img id="peerAvatar" src="" alt="avatar" style="display:none">
      <div class="who">
        <div class="n" id="peerName">Select a contact</div>
        <div class="s" id="peerStatus"></div>
      </div>
    </div>

    <div class="body" id="chatBody">
      <div class="placeholder" id="placeholder">Select a contact to start chatting.</div>
      <div class="messages" id="messages" style="display:none"></div>
    </div>

    <div class="composer">
      <div class="input">
        <input id="messageInput" placeholder="Type a message..." autocomplete="off">
      </div>
      <button class="icon-btn" id="attach"><i class="fas fa-paperclip"></i></button>
      <button class="send" id="sendBtn"><i class="fas fa-paper-plane"></i></button>
    </div>
  </div>
</div>
<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

/* === Supabase Config === */
const SUPABASE_URL = 'https://dfzshvldanqfvfivjrqi.supabase.co'
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRmenNodmxkYW5xZnZmaXZqcnFpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ4MDIxNTEsImV4cCI6MjA3MDM3ODE1MX0.wdms-6G9eDzRuk1YiCpdyvVS-5CRKCsrq9WWWIFl9HA'
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

/* === Constants === */
const STORAGE_KEY = 'hc_profile'
const DRIVE_FILE_NAME = 'chat.json'

/* === Profile === */
const profile = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null')
if (!profile) { location.href = 'register.html'; throw new Error('No profile found.') }

const myId = profile.id
const myName = profile.name
const myEmail = profile.email
const myAvatar = profile.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(myName)}`
const DRIVE_TOKEN = profile.token || null

/* === State === */
let DRIVE_FILE_ID = null
let chatStore = {}       // { peerId: [ messages ] }
let online = {}          // { uuid: {uuid,name,email,avatar,ts} }
let lastSeen = {}        // { uuid: timestamp }
let pcMap = {}
let dcMap = {}
let currentPeer = null
let typingTimeouts = {}
let driveSaveTimer = null

/* === Elements === */
const avatarEl = document.getElementById('myAvatar')
const nameEl = document.getElementById('myName')
const searchEl = document.getElementById('search')
const logoutEl = document.getElementById('logout')
const chatsTab = document.getElementById('tab-chats')
const onlineTab = document.getElementById('tab-online')
const contactsEl = document.getElementById('contacts')
const messagesEl = document.getElementById('messages')
const placeholderEl = document.getElementById('placeholder')
const peerNameEl = document.getElementById('peerName')
const peerAvatarEl = document.getElementById('peerAvatar')
const peerStatusEl = document.getElementById('peerStatus')
const messageInput = document.getElementById('messageInput')
const sendBtn = document.getElementById('sendBtn')
const attachBtn = document.getElementById('attach')

/* === Initialize UI === */
avatarEl.src = myAvatar
nameEl.textContent = myName

/* === Events === */
logoutEl.addEventListener('click',()=>{
  localStorage.removeItem(STORAGE_KEY)
  location.reload()
})
searchEl.addEventListener('input',()=>renderContacts(searchEl.value.trim()))
chatsTab.addEventListener('click',()=>switchTab('chats'))
onlineTab.addEventListener('click',()=>switchTab('online'))
sendBtn.addEventListener('click',sendMessage)
messageInput.addEventListener('keydown',e=>{
  if(e.key==='Enter') sendMessage()
  else if(currentPeer) sendTyping(currentPeer)
})
attachBtn.addEventListener('click',()=>{
  const input=document.createElement('input')
  input.type='file'; input.accept='image/*'
  input.onchange=e=>{
    const f=e.target.files[0]
    if(!f) return
    const r=new FileReader()
    r.onload=()=>sendImage(r.result)
    r.readAsDataURL(f)
  }
  input.click()
})

/* === Tabs === */
let activeTab = 'chats'
function switchTab(tab){
  activeTab = tab
  chatsTab.classList.toggle('active',tab==='chats')
  onlineTab.classList.toggle('active',tab==='online')
  renderContacts()
}

/* === Render Contacts === */
function renderContacts(filter=''){
  contactsEl.innerHTML=''
  const now = Date.now()
  const list = activeTab==='chats' 
    ? Object.keys(chatStore).map(id=>online[id] || {uuid:id,name:'Unknown',avatar:'https://ui-avatars.com/api/?name=?'})
    : Object.values(online).filter(u=>u.uuid!==myId)
  
  list.sort((a,b)=>{
    const aTime = chatStore[a.uuid]?.slice(-1)[0]?.ts || 0
    const bTime = chatStore[b.uuid]?.slice(-1)[0]?.ts || 0
    return bTime - aTime
  })

  list.forEach(u=>{
    if(filter && !u.name.toLowerCase().includes(filter.toLowerCase())) return
    const lastMsg = chatStore[u.uuid]?.slice(-1)[0]
    const div = document.createElement('div')
    div.className='contact'
    if(currentPeer===u.uuid) div.classList.add('selected')
    const onlineNow = !!online[u.uuid]
    const dot = onlineNow ? `<span class="dot"></span>` : ''
    const lastText = lastMsg ? (lastMsg.isImage ? 'ðŸ“· Image' : lastMsg.text) : 'No messages yet'
    const lastTime = lastMsg ? formatTime(lastMsg.ts) : ''
    div.innerHTML = `
      <img class="avatar" src="${u.avatar}">
      <div class="meta">
        <div class="name">${u.name} ${dot}</div>
        <div class="last">${lastText}</div>
      </div>
      <div class="time">${lastTime}</div>
    `
    div.addEventListener('click',()=>openChat(u))
    contactsEl.appendChild(div)
  })
}

/* === Chat Window === */
function openChat(user){
  currentPeer = user.uuid
  peerNameEl.textContent = user.name
  peerAvatarEl.src = user.avatar
  peerAvatarEl.style.display='block'
  peerStatusEl.textContent = online[user.uuid] ? 'Online' : getOfflineText(user.uuid)
  placeholderEl.style.display='none'
  messagesEl.style.display='flex'
  messagesEl.innerHTML=''
  if(!chatStore[currentPeer]) chatStore[currentPeer]=[]
  chatStore[currentPeer].forEach(m=>renderMessage(m.text,m.me,m.isImage,false))
  if(!pcMap[currentPeer]) createConnection(currentPeer)
  renderContacts()
  scrollBottom()
}

function renderMessage(text,me,isImage,animate=true){
  const div=document.createElement('div')
  div.className='msg '+(me?'me':'other')
  if(isImage){
    const img=document.createElement('img')
    img.src=text
    div.appendChild(img)
  } else div.textContent=text
  if(animate) div.style.opacity=0
  messagesEl.appendChild(div)
  if(animate) requestAnimationFrame(()=>div.style.opacity=1)
  scrollBottom()
}

function renderTyping(){
  if(!document.querySelector('.typing-bubble')){
    const t=document.createElement('div')
    t.className='typing-bubble'
    t.innerHTML='<span></span><span></span><span></span>'
    messagesEl.appendChild(t)
    scrollBottom()
  }
}
function removeTyping(){ const t=document.querySelector('.typing-bubble'); if(t) t.remove() }

function scrollBottom(){ messagesEl.scrollTop=messagesEl.scrollHeight }
function formatTime(ts){
  const d=new Date(ts)
  let h=d.getHours(), m=d.getMinutes().toString().padStart(2,'0')
  const ampm=h>=12?'PM':'AM'; h=h%12||12
  return `${h}:${m} ${ampm}`
}

/* === WebRTC / Supabase === */
async function startRealtime(){
  const presence=supabase.channel('public:presence')
  presence.on('broadcast',{event:'user-presence'},p=>{
    const u=p.payload
    if(!u?.uuid) return
    if(u.action==='join'||u.action==='update'){
      online[u.uuid]=u; lastSeen[u.uuid]=Date.now(); renderContacts()
    } else if(u.action==='leave'){
      delete online[u.uuid]
      lastSeen[u.uuid]=Date.now()
      if(currentPeer===u.uuid) peerStatusEl.textContent=getOfflineText(u.uuid)
      renderContacts()
    }
  })

  const signaling=supabase.channel('public:signaling')
  signaling.on('broadcast',{event:'signal'},async p=>{
    const msg=p.payload
    if(!msg||msg.to!==myId) return
    if(msg.type==='offer') await handleOffer(msg.from,msg.sdp)
    else if(msg.type==='answer') await handleAnswer(msg.from,msg.sdp)
    else if(msg.type==='candidate') await handleCandidate(msg.from,msg.candidate)
    else if(msg.type==='message') appendIncoming(msg.from,msg.data,msg.isImage)
    else if(msg.type==='typing') showTyping(msg.from)
  })

  await presence.subscribe(); await signaling.subscribe()
  broadcastPresence('join')
  setInterval(()=>broadcastPresence('update'),25000)
  window.addEventListener('beforeunload',()=>broadcastPresence('leave'))

  await loadChatFromDrive()
}
function broadcastPresence(action){
  supabase.channel('public:presence').send({
    type:'broadcast',event:'user-presence',
    payload:{uuid:myId,name:myName,email:myEmail,avatar:myAvatar,action,ts:Date.now()}
  })
}

/* === Typing === */
function sendTyping(to){ sendSignal(to,{type:'typing'}) }
function showTyping(from){
  if(currentPeer!==from) return
  peerStatusEl.textContent='Typing...'
  renderTyping()
  clearTimeout(typingTimeouts[from])
  typingTimeouts[from]=setTimeout(()=>{
    removeTyping()
    peerStatusEl.textContent='Online'
  },1500)
}

/* === Connection === */
function createConnection(peer){
  const pc=new RTCPeerConnection()
  const dc=pc.createDataChannel('chat')
  dc.onmessage=e=>appendIncoming(peer,e.data,false)
  dc.onopen=()=>{dcMap[peer]=dc}
  pc.onicecandidate=e=>{if(e.candidate) sendSignal(peer,{type:'candidate',candidate:e.candidate})}
  pc.ondatachannel=e=>{
    e.channel.onmessage=ev=>appendIncoming(peer,ev.data,false)
    e.channel.onopen=()=>{dcMap[peer]=e.channel}
  }
  pcMap[peer]=pc
  makeOffer(peer)
}
async function makeOffer(peer){
  const pc=pcMap[peer]
  const offer=await pc.createOffer()
  await pc.setLocalDescription(offer)
  sendSignal(peer,{type:'offer',sdp:offer})
}
async function handleOffer(from,sdp){
  if(!pcMap[from]){
    const pc=new RTCPeerConnection()
    pc.ondatachannel=e=>{
      e.channel.onmessage=ev=>appendIncoming(from,ev.data,false)
      e.channel.onopen=()=>{dcMap[from]=e.channel}
    }
    pc.onicecandidate=e=>{if(e.candidate) sendSignal(from,{type:'candidate',candidate:e.candidate})}
    pcMap[from]=pc
  }
  const pc=pcMap[from]
  await pc.setRemoteDescription(new RTCSessionDescription(sdp))
  const answer=await pc.createAnswer()
  await pc.setLocalDescription(answer)
  sendSignal(from,{type:'answer',sdp:answer})
}
async function handleAnswer(from,sdp){ await pcMap[from]?.setRemoteDescription(new RTCSessionDescription(sdp)) }
async function handleCandidate(from,candidate){ await pcMap[from]?.addIceCandidate(new RTCIceCandidate(candidate)) }
function sendSignal(to,msg){ supabase.channel('public:signaling').send({type:'broadcast',event:'signal',payload:{...msg,from:myId,to}}) }

/* === Message Sending === */
function sendMessage(){
  if(!currentPeer) return
  const val=messageInput.value.trim()
  if(!val) return
  pushMessage(currentPeer,val,true,false)
  if(dcMap[currentPeer]?.readyState==='open') dcMap[currentPeer].send(val)
  sendSignal(currentPeer,{type:'message',data:val,isImage:false})
  messageInput.value=''
}
function sendImage(data){
  if(!currentPeer) return
  pushMessage(currentPeer,data,true,true)
  if(dcMap[currentPeer]?.readyState==='open') dcMap[currentPeer].send(data)
  sendSignal(currentPeer,{type:'message',data:data,isImage:true})
}
function appendIncoming(from,text,isImage){
  pushMessage(from,text,false,!!isImage)
  if(currentPeer===from) renderMessage(text,false,!!isImage)
  renderContacts()
  scheduleDriveSave()
}
function pushMessage(peer,text,me,isImage){
  if(!chatStore[peer]) chatStore[peer]=[]
  chatStore[peer].push({
    text,me,isImage,ts:Date.now(),read:me,
    senderEmail:me?myEmail:online[peer]?.email||'',
    senderName:me?myName:online[peer]?.name||'',
    receiverEmail:me?(online[peer]?.email||'') : myEmail,
    receiverName:me?(online[peer]?.name||'') : myName
  })
  if(me) renderMessage(text,true,isImage)
  scheduleDriveSave()
}

/* === Drive Sync === */
async function loadChatFromDrive(){
  if(!DRIVE_TOKEN) return
  try{
    const listRes=await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${DRIVE_FILE_NAME}' and trashed=false&fields=files(id,name)`,{
      headers:{Authorization:'Bearer '+DRIVE_TOKEN}
    })
    const listData=await listRes.json()
    DRIVE_FILE_ID=listData.files?.[0]?.id || null
    if(DRIVE_FILE_ID){
      const fileRes=await fetch(`https://www.googleapis.com/drive/v3/files/${DRIVE_FILE_ID}?alt=media`,{
        headers:{Authorization:'Bearer '+DRIVE_TOKEN}
      })
      if(fileRes.ok){
        const data=await fileRes.json().catch(()=>({}))
        if(data&&typeof data==='object') chatStore=data
      }
    } else await updateDrive()
  }catch(e){ console.error('Drive load error',e) }
  renderContacts()
}
function scheduleDriveSave(){
  if(!DRIVE_TOKEN) return
  clearTimeout(driveSaveTimer)
  driveSaveTimer=setTimeout(()=>updateDrive(),2000)
}
async function updateDrive(){
  if(!DRIVE_TOKEN) return
  try{
    const metadata={name:DRIVE_FILE_NAME,mimeType:'application/json'}
    const form=new FormData()
    form.append('metadata',new Blob([JSON.stringify(metadata)],{type:'application/json'}))
    form.append('file',new Blob([JSON.stringify(chatStore)],{type:'application/json'}))
    const uploadUrl=DRIVE_FILE_ID
      ? `https://www.googleapis.com/upload/drive/v3/files/${DRIVE_FILE_ID}?uploadType=multipart`
      : 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart'
    const res=await fetch(uploadUrl,{method:DRIVE_FILE_ID?'PATCH':'POST',headers:{Authorization:'Bearer '+DRIVE_TOKEN},body:form})
    if(res.ok){const j=await res.json(); DRIVE_FILE_ID=j.id||DRIVE_FILE_ID}
  }catch(e){console.error('Drive save error',e)}
}

/* === Helpers === */
function getOfflineText(id){
  const t=lastSeen[id]
  if(!t) return 'Offline'
  const diff=Math.floor((Date.now()-t)/60000)
  if(diff<1) return 'Just went offline'
  if(diff===1) return 'Went offline 1 min ago'
  return `Went offline ${diff} mins ago`
}

/* === Init === */
startRealtime()
</script>


</body>
</html>






