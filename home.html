<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hybrid â€” Chat</title>
<link rel="icon" href="hybrid.png" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<style>
:root {
  --bg:#e6eefc;
  --side:#ffffff;
  --card:#ffffff;
  --primary:#2b9cff;
  --primary-600:#257ed6;
  --muted:#6b7280;
  --shadow:0 12px 30px rgba(16,24,40,0.08);
  --radius:14px;
}

* {
  box-sizing:border-box;
  margin:0;
  padding:0;
  font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,'Helvetica Neue',Arial;
}

html,body {
  height:100%;
  overflow:hidden;
  background:linear-gradient(180deg,#f6fbff 0%,#e6eefc 100%);
  scroll-behavior:smooth;
}

body {
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:100vh;
  padding:24px;
  animation:fadeInBody .5s ease;
}

@keyframes fadeInBody {
  from {opacity:0;transform:translateY(20px);}
  to {opacity:1;transform:none;}
}

/* ---- MAIN APP ---- */
.app {
  width:100%;
  max-width:1100px;
  height:90vh;
  display:grid;
  grid-template-columns:320px 1fr;
  gap:20px;
  overflow:hidden;
  animation:fadeIn .4s ease;
}

@keyframes fadeIn {
  from {opacity:0;transform:translateY(20px);}
  to {opacity:1;transform:none;}
}

/* ---- SIDE PANEL ---- */
.panel {
  background:var(--side);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  display:flex;
  flex-direction:column;
  overflow:hidden;
  transition:all .3s ease;
  height:100%;
}

.panel .header {
  padding:18px 16px;
  display:flex;
  align-items:center;
  gap:12px;
  border-bottom:1px solid rgba(15,23,42,0.04);
}

.panel .title {
  font-weight:700;
  color:#0f172a;
  font-size:16px;
}

.panel .subtitle {
  color:var(--muted);
  font-size:12px;
  margin-top:4px;
}

.search {
  padding:12px 14px;
  border-bottom:1px solid rgba(15,23,42,0.04);
  display:flex;
  gap:8px;
  align-items:center;
}

.search input {
  flex:1;
  border-radius:12px;
  padding:10px 12px;
  border:1px solid rgba(15,23,42,0.06);
  outline:none;
  background:#fbfdff;
  font-size:14px;
  color:#071133;
  transition:box-shadow .18s ease;
}

.search input:focus {
  box-shadow:0 6px 18px rgba(43,156,255,0.12);
  border-color:var(--primary-600);
}

.list {
  padding:12px;
  flex:1;
  overflow-y:auto;
  display:flex;
  flex-direction:column;
  gap:8px;
  scroll-behavior:smooth;
}

.contact {
  display:flex;
  align-items:center;
  gap:12px;
  padding:10px;
  border-radius:12px;
  cursor:pointer;
  transition:background .12s ease,transform .12s ease;
}

.contact:hover {
  background:rgba(43,156,255,0.04);
  transform:translateY(-2px);
}

.contact.selected {
  background:linear-gradient(90deg,var(--primary) 0%,var(--primary-600) 100%);
  color:white;
  box-shadow:0 10px 30px rgba(43,156,255,0.12);
}

.avatar {
  width:48px;
  height:48px;
  border-radius:50%;
  object-fit:cover;
  box-shadow:0 6px 18px rgba(2,6,23,0.06);
}

.meta {
  display:flex;
  flex-direction:column;
  gap:4px;
  min-width:0;
}

.meta .name {
  font-weight:600;
  font-size:15px;
  color:#071133;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

.contact.selected .name {
  color:white;
}

.meta .last {
  color:var(--muted);
  font-size:13px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

.contact.selected .last {
  color:rgba(255,255,255,0.9);
}

/* ---- CHAT ---- */
.chat {
  background:linear-gradient(180deg,#ffffff,#f7fbff);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  display:flex;
  flex-direction:column;
  overflow:hidden;
  height:100%;
  min-height:0;
  transition:all .3s ease;
}

.chat .top {
  padding:14px 18px;
  display:flex;
  align-items:center;
  gap:12px;
  border-bottom:1px solid rgba(15,23,42,0.04);
}

.chat .top img {
  width:44px;
  height:44px;
  border-radius:50%;
  object-fit:cover;
  transition:all .3s ease;
}

.chat .who {
  display:flex;
  flex-direction:column;
}

.chat .n {
  font-weight:700;
  color:#071133;
  transition:color .3s ease;
}

.chat .s {
  font-size:13px;
  color:var(--muted);
}

.chat .body {
  flex:1;
  overflow-y:auto;
  padding:20px;
  display:flex;
  flex-direction:column;
  background:linear-gradient(180deg,#f7fbff00,#ffffff00);
  scroll-behavior:smooth;
  min-height:0;
  -webkit-overflow-scrolling:touch;
}

.messages {
  display:flex;
  flex-direction:column;
  gap:8px;
  width:100%;
  margin-top:auto;
  margin-bottom:auto;
}

.msg {
  display:inline-block;
  max-width:72%;
  padding:12px 14px;
  border-radius:18px;
  font-size:15px;
  line-height:1.3;
  box-shadow:0 6px 20px rgba(2,6,23,0.06);
  opacity:0;
  transform:translateY(8px);
  animation:pop .22s ease forwards;
}

@keyframes pop {
  to {opacity:1;transform:none;}
}

.msg.me {
  background:linear-gradient(180deg,var(--primary),var(--primary-600));
  color:white;
  align-self:flex-end;
  border-bottom-right-radius:6px;
}

.msg.other {
  background:#fff;
  color:#071133;
  align-self:flex-start;
  border-bottom-left-radius:6px;
}

.msg img {
  max-width:300px;
  border-radius:12px;
  display:block;
}

.placeholder {
  display:flex;
  align-items:center;
  justify-content:center;
  color:var(--muted);
  font-size:15px;
}

.composer {
  padding:12px;
  border-top:1px solid rgba(15,23,42,0.04);
  display:flex;
  gap:8px;
  align-items:center;
  background:linear-gradient(180deg,#ffffff,#f7fbff);
}

.input {
  flex:1;
  background:#f3f6ff;
  padding:10px 14px;
  border-radius:999px;
  display:flex;
  gap:8px;
  align-items:center;
  box-shadow:inset 0 1px 0 rgba(255,255,255,0.6);
}

.input input {
  flex:1;
  border:none;
  background:transparent;
  outline:none;
  font-size:15px;
  color:#071133;
}

.icon-btn {
  width:44px;
  height:44px;
  border-radius:50%;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  border:none;
  background:transparent;
  color:var(--primary);
  font-size:18px;
  transition:all .2s ease;
}

.icon-btn:hover {
  transform:scale(1.15);
}

.send {
  width:48px;
  height:44px;
  border-radius:12px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:linear-gradient(180deg,var(--primary),var(--primary-600));
  color:white;
  font-size:18px;
  border:none;
  cursor:pointer;
  box-shadow:0 10px 24px rgba(43,156,255,0.14);
  transition:transform .2s ease;
}

.send:hover {
  transform:scale(1.05);
}

/* ---- CALL DIALOG ---- */
.call-dialog {
  position:fixed;
  bottom:20px;
  right:20px;
  width:350px;
  height:500px;
  background:linear-gradient(145deg,#f9f9f9,#e0e0e0);
  border-radius:20px;
  box-shadow:0 15px 40px rgba(0,0,0,0.25);
  display:flex;
  flex-direction:column;
  overflow:hidden;
  animation:fadeIn .4s ease;
  z-index:9999;
  font-family:'Segoe UI',sans-serif;
  transition:all .3s ease;
}

.call-header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:15px 20px;
  background:#fff;
  box-shadow:0 3px 6px rgba(0,0,0,0.1);
  border-bottom-left-radius:20px;
  border-bottom-right-radius:20px;
  animation:fadeSlideDown .4s ease;
}

@keyframes fadeSlideDown {
  from {opacity:0;transform:translateY(-15px);}
  to {opacity:1;transform:none;}
}

.call-header .profile {
  display:flex;
  align-items:center;
  gap:12px;
}

.call-header .profile img {
  width:55px;
  height:55px;
  border-radius:50%;
  border:3px solid #10b981;
  object-fit:cover;
  box-shadow:0 4px 15px rgba(0,0,0,0.15);
  transition:all .3s ease;
}

.call-header .profile img:hover {
  transform:scale(1.05);
}

.call-header .profile .name-status {
  display:flex;
  flex-direction:column;
  line-height:1.2;
}

.call-header .profile .name-status .name {
  font-weight:700;
  font-size:17px;
  color:#111827;
}

.call-header .profile .name-status .status {
  font-size:13px;
  color:#6b7280;
}

.call-body {
  flex:1;
  position:relative;
  background:#000;
  border-radius:15px;
  overflow:hidden;
}

.call-body video {
  width:100%;
  height:100%;
  object-fit:cover;
  border-radius:15px;
  background:#000;
}

#localVideo {
  width:100px;
  height:140px;
  position:absolute;
  top:15px;
  right:15px;
  border-radius:12px;
  border:3px solid #fff;
  box-shadow:0 4px 15px rgba(0,0,0,0.25);
  object-fit:cover;
}

.call-actions {
  display:flex;
  justify-content:space-around;
  align-items:center;
  padding:15px 0;
  background:#f9fafb;
  border-top-left-radius:15px;
  border-top-right-radius:15px;
  gap:20px;
}

.icon-btn {
  background:#fff;
  border-radius:50%;
  width:50px;
  height:50px;
  display:flex;
  justify-content:center;
  align-items:center;
  font-size:20px;
  cursor:pointer;
  transition:all 0.2s ease;
  box-shadow:0 4px 12px rgba(0,0,0,0.15);
}

.icon-btn:hover {
  transform:scale(1.1);
  box-shadow:0 6px 18px rgba(0,0,0,0.25);
}

.end-call {
  background:#ef4444;
  color:#fff;
}

.incoming-actions {
  position:absolute;
  bottom:30px;
  width:100%;
  display:flex;
  justify-content:space-around;
  gap:20px;
}

.accept-btn,
.decline-btn {
  padding:12px 28px;
  border-radius:30px;
  font-weight:600;
  border:none;
  cursor:pointer;
  font-size:15px;
  transition:all 0.2s ease;
}

.accept-btn {
  background:#10b981;
  color:#fff;
  box-shadow:0 4px 12px rgba(16,185,129,0.3);
}

.accept-btn:hover {
  transform:scale(1.05);
  box-shadow:0 6px 18px rgba(16,185,129,0.45);
}

.decline-btn {
  background:#ef4444;
  color:#fff;
  box-shadow:0 4px 12px rgba(239,68,68,0.3);
}

.decline-btn:hover {
  transform:scale(1.05);
  box-shadow:0 6px 18px rgba(239,68,68,0.45);
}

/* ---- RESPONSIVE ---- */
@media (max-width:900px){
  body {
    padding:12px;
    overflow:auto;
    align-items:flex-start;
  }
  .app {
    grid-template-columns:1fr;
    gap:12px;
    max-width:720px;
    height:auto;
    display:flex;
    flex-direction:column;
  }
  .panel {
    order:2;
    min-height:35vh;
    max-height:40vh;
    border-radius:12px;
    overflow-y:auto;
  }
  .chat {
    order:1;
    min-height:55vh;
    max-height:none;
  }
  .chat .body {
    flex:1;
    overflow-y:auto;
  }
  .call-dialog {
    width:90%;
    height:auto;
    bottom:10px;
    right:5%;
    border-radius:18px;
  }
}
</style>


</head>
<body>
  
<!-- Video/Voice Call Dialog -->
<div id="callDialog" class="call-dialog" style="display:none;">
  <div class="call-header">
    <div class="peer-info">
      <img id="callPeerAvatar" src="" alt="avatar">
      <span id="callPeerName">Calling...</span>
    </div>
    <button class="icon-btn" id="callCloseBtn"><i class="fas fa-times"></i></button>
  </div>

  <div class="call-body">
    <video id="remoteVideo" autoplay playsinline></video>
    <video id="localVideo" autoplay playsinline muted></video>
    <div id="incomingActions" class="incoming-actions" style="display:none;">
      <button id="acceptCallBtn" class="accept-btn"><i class="fas fa-phone"></i> Accept</button>
      <button id="declineCallBtn" class="decline-btn"><i class="fas fa-phone-slash"></i> Decline</button>
    </div>
  </div>

  <div class="call-actions" style="display:none;">
    <button id="muteBtn" class="icon-btn"><i class="fas fa-microphone"></i></button>
    <button id="cameraBtn" class="icon-btn"><i class="fas fa-video"></i></button>
    <button id="switchBtn" class="icon-btn"><i class="fas fa-camera"></i></button>
    <button id="hangupBtn" class="icon-btn end-call"><i class="fas fa-phone-slash"></i></button>
  </div>
</div>

    <div id="onlineDialog" class="dialog" style="display:none;">
  <div class="dialog-content">
    <div class="dialog-header">
      <h3>Online Users</h3>
      <button class="icon-btn" id="closeDialog"><i class="fas fa-times"></i></button>
    </div>
    <div id="onlineList" class="dialog-list"></div>
  </div>
</div>
  
<div class="app" id="app">
  <div class="panel" id="sidebar">
    <div class="header">
      <div style="display:flex;flex-direction:column">
        <div class="title">Hybrid</div>
        <div class="subtitle">messaging</div>
      </div>
    </div>
    <div class="search">
      <input id="search" placeholder="Search people or paste id..." autocomplete="off">
      <button class="icon-btn" id="addBtn" title="Add by ID"><i class="fas fa-user-plus"></i></button>
    </div>
    <div class="list" id="contacts"></div>
    <div style="padding:12px;border-top:1px dashed rgba(15,23,42,0.04);display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div style="display:flex;gap:8px;align-items:center">
        <img id="myAvatar" src="" style="width:42px;height:42px;border-radius:50%;object-fit:cover">
        <div style="font-size:13px;color:#071133;font-weight:600" id="myName"></div>
      </div>
      <button id="logout" class="icon-btn" style="background:#fff;color:#ef4444;border-radius:10px;"><i class="fas fa-right-from-bracket"></i></button>
    </div>
  </div>
  <div class="chat" id="chat">
    <div class="top">
  <img id="peerAvatar" src="" alt="avatar" style="display:none">
  <div class="who">
    <div class="n" id="peerName">Select a contact</div>
    <div class="s" id="peerStatus"></div>
  </div>
  <div class="chat-actions" id="chatActions" style="display:none">
  <button class="icon-btn" id="videoCallBtn"><i class="fas fa-video"></i></button>
  <button class="icon-btn" id="audioCallBtn"><i class="fas fa-phone"></i></button>
</div>

</div>

    <div class="body" id="chatBody">
      <div class="placeholder" id="placeholder">Select a contact to start chatting.</div>
      <div class="messages" id="messages" style="display:none"></div>
    </div>
    <div class="composer">
      <div class="input">
        <input id="messageInput" placeholder="Type a message..." autocomplete="off">
      </div>
      <button class="icon-btn" id="attach"><i class="fas fa-paperclip"></i></button>
      <button class="send" id="sendBtn"><i class="fas fa-paper-plane"></i></button>
    </div>
  </div>
</div>

<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

const SUPABASE_URL = 'https://dfzshvldanqfvfivjrqi.supabase.co'
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRmenNodmxkYW5xZnZmaXZqcnFpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ4MDIxNTEsImV4cCI6MjA3MDM3ODE1MX0.wdms-6G9eDzRuk1YiCpdyvVS-5CRKCsrq9WWWIFl9HA'
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

const DRIVE_FILE_NAME = 'chat.json'
const STORAGE_KEY = 'hc_profile'
const profile = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null')
if (!profile) { location.href = 'register.html'; throw new Error('No profile') }

const MY_ID = profile.id
const MY_NAME = profile.name
const MY_AVATAR = profile.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(profile.name)}`
const DRIVE_TOKEN = profile.token

const contactsEl = document.getElementById('contacts')
const searchEl = document.getElementById('search')
const addBtn = document.getElementById('addBtn')
const logoutBtn = document.getElementById('logout')
const peerAvatarEl = document.getElementById('peerAvatar')
const peerNameEl = document.getElementById('peerName')
const peerStatusEl = document.getElementById('peerStatus')
const placeholderEl = document.getElementById('placeholder')
const messagesEl = document.getElementById('messages')
const messageInput = document.getElementById('messageInput')
const sendBtn = document.getElementById('sendBtn')
const attachBtn = document.getElementById('attach')
document.getElementById('myAvatar').src = MY_AVATAR
document.getElementById('myName').textContent = MY_NAME
const videoCallBtn = document.getElementById('videoCallBtn');
const audioCallBtn = document.getElementById('audioCallBtn');

videoCallBtn.onclick = () => {
  if (!currentPeer) return alert('Select a contact first.');
  startCall(currentPeer, true); // video call
}

audioCallBtn.onclick = () => {
  if (!currentPeer) return alert('Select a contact first.');
  startCall(currentPeer, false); // audio only call
}

let chatStore = {}
let online = {}
let currentPeer = null
let DRIVE_FILE_ID = null
let typingTimeout = {}
let pcMap = {}, dcMap = {}
const typingIndicators = {}


function showTyping(peerId) {
  if (typingIndicators[peerId]) return;
  const name = chatStore[peerId]?.profile?.name || 'User';
  const d = document.createElement('div');
  d.className = 'typing-indicator';
  d.id = `typing-${peerId}`;
  d.innerHTML = `<span class="label">${name} is typing</span>
    <div class="typing-dots"><span></span><span></span><span></span></div>`;
  messagesEl.appendChild(d);
  typingIndicators[peerId] = d;
  requestAnimationFrame(() => scrollElementIntoView(d, true));
}
function hideTyping(peerId) {
  const el = typingIndicators[peerId];
  if (!el) return;
  el.style.transition = 'opacity .18s ease, transform .18s ease';
  el.style.opacity = '0';
  el.style.transform = 'translateY(8px)';
  setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 200);
  delete typingIndicators[peerId];
}

// ---- UI: Contacts ----
function renderContacts(filter = '') {
  contactsEl.innerHTML = ''
 
  const sorted = Object.values(chatStore)
  .filter(c => c.messages && c.messages.length > 0)
  .sort((a, b) => (b.lastTs || 0) - (a.lastTs || 0))
  .filter(c => !filter || c.profile.name.toLowerCase().includes(filter.toLowerCase()));
 if (sorted.length === 0) {
  contactsEl.innerHTML = `<div style="text-align:center;color:#64748b;padding:20px">No chats yet</div>`;
  return;
}
  for (const c of sorted) {
    const u = c.profile
    const lastMsg = c.messages.slice(-1)[0]
    const unread = c.unreadCount > 0
    const div = document.createElement('div')
    div.className = 'contact' + (currentPeer === u.uuid ? ' selected' : '')
    div.innerHTML = `
      <img class="avatar" src="${u.avatar}">
      <div class="meta">
        <div class="name" style="font-weight:${unread ? '700' : '500'}">${u.name}</div>
        <div class="last">${lastMsg ? (lastMsg.isImage ? 'ðŸ“· Image' : lastMsg.text) : 'No messages yet'}</div>
      </div>`
    div.onclick = () => openChat(u.uuid)
    contactsEl.appendChild(div)
  }
}
const callDialog = document.getElementById('callDialog');
const callPeerName = document.getElementById('callPeerName');
const callPeerAvatar = document.getElementById('callPeerAvatar');
const remoteVideo = document.getElementById('remoteVideo');
const localVideo = document.getElementById('localVideo');
const incomingActions = document.getElementById('incomingActions');
const acceptCallBtn = document.getElementById('acceptCallBtn');
const declineCallBtn = document.getElementById('declineCallBtn');
const callActions = callDialog.querySelector('.call-actions');
const muteBtn = document.getElementById('muteBtn');
const cameraBtn = document.getElementById('cameraBtn');
const switchBtn = document.getElementById('switchBtn');
const hangupBtn = document.getElementById('hangupBtn');
const callCloseBtn = document.getElementById('callCloseBtn');

let callPC = null, localStream = null;
let currentCallPeer = null, isCalling = false;
const STUN_CONFIG = { iceServers:[{urls:'stun:stun.l.google.com:19302'}] };

// --- Outgoing Call ---
async function startCall(peerId, isVideo=true){
  if(isCalling){ alert('You are already in a call.'); return; }
  if(online[peerId]===false){ alert('The person is offline.'); return; }
  currentCallPeer = peerId; isCalling=true;

  callPC = new RTCPeerConnection(STUN_CONFIG);
  callPC.onicecandidate = e=>{ if(e.candidate) sendSignal(peerId,{type:'candidate',candidate:e.candidate}); };
  callPC.ontrack = e=>{ remoteVideo.srcObject = e.streams[0]; };

  localStream = await navigator.mediaDevices.getUserMedia({video:isVideo,audio:true});
  localStream.getTracks().forEach(track=>callPC.addTrack(track,localStream));
  localVideo.srcObject = localStream;

  const offer = await callPC.createOffer();
  await callPC.setLocalDescription(offer);
  sendSignal(peerId,{type:'call-offer',sdp:offer,video:isVideo});

  showCallDialog(peerId,true,false);
}

// --- Incoming Call ---
async function handleCallOffer(from,sdp,isVideo){
  if(isCalling){ sendSignal(from,{type:'busy'}); return; }
  currentCallPeer = from; isCalling=true;

  callPC = new RTCPeerConnection(STUN_CONFIG);
  callPC.onicecandidate = e => {
  if (e.candidate)
    sendSignal(currentCallPeer, { type: 'candidate', candidate: e.candidate, isCall: true });
};

  callPC.ontrack = e=>{ remoteVideo.srcObject = e.streams[0]; };

  localStream = await navigator.mediaDevices.getUserMedia({video:isVideo,audio:true});
  localStream.getTracks().forEach(track=>callPC.addTrack(track,localStream));
  localVideo.srcObject = localStream;

  callPC.remoteSDP = sdp; // save to answer later
  showCallDialog(from,false,true); // show incoming actions
}

acceptCallBtn.onclick = async ()=>{
  callActions.style.display = 'flex';
  incomingActions.style.display = 'none';

  await callPC.setRemoteDescription(new RTCSessionDescription(callPC.remoteSDP));
  const answer = await callPC.createAnswer();
  await callPC.setLocalDescription(answer);
  sendSignal(currentCallPeer,{type:'call-answer',sdp:answer});
}

declineCallBtn.onclick = ()=>{
  sendSignal(currentCallPeer,{type:'decline'});
  endCall();
}

async function handleCallAnswer(from,sdp){ await callPC.setRemoteDescription(new RTCSessionDescription(sdp)); }

function handleBusy(){ alert('The person you are calling is busy.'); endCall(); }
function handleDecline(){ alert('Call declined.'); endCall(); }


function endCall(){
  if(callPC) callPC.close();
  if(localStream) localStream.getTracks().forEach(t=>t.stop());
  callPC=null; localStream=null; isCalling=false; currentCallPeer=null;
  callDialog.style.display='none';
}

  
function showCallDialog(peerId,isOutgoing=false,isIncoming=false){
  callDialog.style.display='flex';
  
  const peer = chatStore[peerId]?.profile || { name: 'User', avatar: `https://ui-avatars.com/api/?name=User` };
  
  callPeerAvatar.src = peer.avatar;
  callPeerAvatar.style.width = '60px';
  callPeerAvatar.style.height = '60px';
  callPeerAvatar.style.borderRadius = '50%';
  callPeerAvatar.style.border = '3px solid #10b981';
  callPeerAvatar.style.boxShadow = '0 4px 12px rgba(0,0,0,0.25)';
  callPeerAvatar.style.objectFit = 'cover';
  callPeerAvatar.style.transition = 'all 0.3s ease';
  
  callPeerName.textContent = peer.name;
  callPeerName.style.fontSize = '18px';
  callPeerName.style.fontWeight = '700';
  callPeerName.style.color = '#111827';
  callPeerName.style.marginLeft = '12px';
  callPeerName.style.transition = 'all 0.3s ease';

  const parent = callPeerName.parentElement;
  parent.style.display = 'flex';
  parent.style.alignItems = 'center';
  parent.style.padding = '12px 20px';
  parent.style.background = 'linear-gradient(135deg, #f3f4f6, #e5e7eb)';
  parent.style.borderRadius = '15px';
  parent.style.boxShadow = '0 6px 18px rgba(0,0,0,0.12)';
  
  callActions.style.display = isOutgoing ? 'flex' : 'none';
  incomingActions.style.display = isIncoming ? 'flex' : 'none';
}

  
hangupBtn.onclick = callCloseBtn.onclick = endCall;
muteBtn.onclick = ()=>{ localStream.getAudioTracks()[0].enabled = !localStream.getAudioTracks()[0].enabled; }
cameraBtn.onclick = ()=>{ localStream.getVideoTracks()[0].enabled = !localStream.getVideoTracks()[0].enabled; }
switchBtn.onclick = async ()=>{
  const videoTrack = localStream.getVideoTracks()[0];
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cameras = devices.filter(d=>d.kind==='videoinput');
  if(cameras.length<2) return;
  const newDevice = cameras.find(d=>d.deviceId!==videoTrack.getSettings().deviceId);
  const newStream = await navigator.mediaDevices.getUserMedia({video:{deviceId:newDevice.deviceId},audio:false});
  const sender = callPC.getSenders().find(s=>s.track.kind==='video');
  sender.replaceTrack(newStream.getVideoTracks()[0]);
  localStream.removeTrack(videoTrack); localStream.addTrack(newStream.getVideoTracks()[0]);
  localVideo.srcObject = localStream;
}
function openChat(peerId) {
  currentPeer = peerId
  const peer = chatStore[peerId].profile
  chatStore[peerId].unreadCount = 0
  peerNameEl.textContent = peer.name
  peerAvatarEl.src = peer.avatar
  peerAvatarEl.style.display = 'block'
  updatePeerStatus(peerId)
  document.getElementById('chatActions').style.display = 'flex';

  placeholderEl.style.display = 'none'
  messagesEl.style.display = 'flex'
  messagesEl.innerHTML = ''

  for (const msg of chatStore[peerId].messages)
    renderMessage(msg.text, msg.me, msg.isImage, false)

  if (!pcMap[peerId]) createConnection(peerId)
  saveToDrive()
  renderContacts()
  scrollBottom()
}

function renderMessage(text, me, isImage, animate = true) {
  const d = document.createElement('div');
  d.className = 'msg ' + (me ? 'me' : 'other');
  if (isImage) {
    const img = document.createElement('img');
    img.src = text;
    img.alt = 'Image message';
    img.style.opacity = '0';
    img.style.transition = 'opacity .25s ease';
    d.appendChild(img);
    messagesEl.appendChild(d);
    img.onload = () => {
      img.style.opacity = '1';
      requestAnimationFrame(() => scrollElementIntoView(d, true));
    };
    img.onerror = () => {
      img.style.opacity = '1';
      requestAnimationFrame(() => scrollElementIntoView(d, true));
    };
  } else {
    d.textContent = text;
    messagesEl.appendChild(d);
    if (animate) { d.style.opacity = 0; requestAnimationFrame(() => d.style.opacity = 1); }
    requestAnimationFrame(() => scrollElementIntoView(d, true));
  }
}
function scrollElementIntoView(el, smooth = true) {
  try {
    el.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'end', inline: 'nearest' });
  } catch {
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
}
  function resetChatView() {
  placeholderEl.style.display = 'flex';
  messagesEl.style.display = 'none';
  document.getElementById('chatActions').style.display = 'none';
}
resetChatView();

function scrollBottom(smooth = true) {
  const last = messagesEl.lastElementChild;
  if (last) scrollElementIntoView(last, smooth);
  else messagesEl.scrollTop = messagesEl.scrollHeight;
}
function sendMessage() {
  if (!currentPeer) return
  const val = messageInput.value.trim()
  if (!val) return
  const ts = Date.now()
  const msg = { id: ts + '-me', text: val, ts, me: true, isImage: false }
  chatStore[currentPeer].messages.push(msg)
  chatStore[currentPeer].lastTs = ts
  renderMessage(val, true, false)
  messageInput.value = ''

  const payload = { text: val, ts, id: msg.id, isImage: false }
  if (dcMap[currentPeer]?.readyState === 'open')
    dcMap[currentPeer].send(JSON.stringify(payload))
  else
    sendSignal(currentPeer, { type: 'message', data: val, ts, id: msg.id, isImage: false })

  saveToDrive()
  renderContacts()
}

function appendIncoming(from, text, isImage, ts, id) {
  hideTyping(from)
  const chat = chatStore[from] || (chatStore[from] = { profile: { uuid: from, name: 'User', avatar: `https://ui-avatars.com/api/?name=User` }, messages: [], unreadCount: 0 })
  if (chat.messages.some(m => m.id === id)) return
  chat.messages.push({ id, text, me: false, isImage, ts })
  chat.lastTs = ts
  if (currentPeer === from) renderMessage(text, false, isImage)
  else chat.unreadCount++
  renderContacts()
  saveToDrive()
}
attachBtn.onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = async e => {
    const f = e.target.files[0];
    if (!f) return;
    const dataUrl = await resizeAndCompress(f, 200, 200, 0.3, 25); // target 25KB
    sendImageMessage(dataUrl);
  };
  input.click();
};

async function resizeAndCompress(file, maxWidth, maxHeight, initialQuality = 0.3, targetKB = 25) {
  return new Promise((resolve) => {
    const img = new Image();
    const reader = new FileReader();
    reader.onload = e => img.src = e.target.result;
    img.onload = () => {
      let { width, height } = img;

      // maintain aspect ratio
      const scale = Math.min(maxWidth / width, maxHeight / height, 1);
      width = width * scale;
      height = height * scale;

      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, width, height);

      let quality = initialQuality;
      let compressed = canvas.toDataURL('image/jpeg', quality);
      let sizeKB = Math.round((compressed.length * 3 / 4) / 1024);

      // reduce quality in small steps until < targetKB
      while (sizeKB > targetKB && quality > 0.05) {
        quality -= 0.05;
        compressed = canvas.toDataURL('image/jpeg', quality);
        sizeKB = Math.round((compressed.length * 3 / 4) / 1024);
      }

      resolve(compressed);
    };
    reader.readAsDataURL(file);
  });
}



function sendImageMessage(dataUrl) {
  if (!currentPeer) return
  const ts = Date.now()
  const msg = { id: ts + '-me', text: dataUrl, ts, me: true, isImage: true }
  chatStore[currentPeer].messages.push(msg)
  chatStore[currentPeer].lastTs = ts
  renderMessage(dataUrl, true, true)

  const payload = { text: dataUrl, ts, id: msg.id, isImage: true }
  if (dcMap[currentPeer]?.readyState === 'open')
    dcMap[currentPeer].send(JSON.stringify(payload))
  else sendSignal(currentPeer, { type: 'message', data: dataUrl, ts, id: msg.id, isImage: true })

  saveToDrive()
  renderContacts()
}

// ---- Supabase Presence & Signaling ----
async function startRealtime() {
  const presence = supabase.channel('presence')
  const signaling = supabase.channel('signaling')

  presence.on('broadcast', { event: 'presence' }, ({ payload }) => {
    if (!payload?.uuid) return
    if (payload.action === 'join' || payload.action === 'update') {
      online[payload.uuid] = true
      chatStore[payload.uuid] = chatStore[payload.uuid] || { profile: payload, messages: [], unreadCount: 0 }
    } else if (payload.action === 'leave') {
      online[payload.uuid] = false
      chatStore[payload.uuid].lastSeen = Date.now()
    }
    renderContacts()
    if (payload.uuid === currentPeer) updatePeerStatus(currentPeer)
  })

 signaling.on('broadcast', { event: 'signal' }, async ({ payload }) => {
  if (!payload || payload.to !== MY_ID) return;

  switch(payload.type) {
    case 'offer': await handleOffer(payload.from, payload.sdp); break;
    case 'answer': await handleAnswer(payload.from, payload.sdp); break;
    case 'candidate': 
      await handleCandidate(payload.from, payload.candidate, !!payload.isCall); 
      break;

    case 'call-offer': handleCallOffer(payload.from, payload.sdp, payload.video); break;
    case 'call-answer': handleCallAnswer(payload.from, payload.sdp); break;
    case 'busy': handleBusy(); break;
    case 'decline': handleDecline(); break;

    case 'message': appendIncoming(payload.from, payload.data, payload.isImage, payload.ts, payload.id); break;
    case 'typing': if (payload.from === currentPeer) showTyping(payload.from); break;
    case 'stopTyping': hideTyping(payload.from); break;
  }
});


  await presence.subscribe()
  await signaling.subscribe()
  setInterval(() => sendPresence('update'), 25000)
  window.addEventListener('beforeunload', () => sendPresence('leave'))
  sendPresence('join')

  await fetchDriveData()
}

function sendPresence(action) {
  supabase.channel('presence').send({
    type: 'broadcast', event: 'presence',
    payload: { uuid: MY_ID, name: MY_NAME, avatar: MY_AVATAR, action, ts: Date.now() }
  })
}
function sendSignal(to, msg) {
  supabase.channel('signaling').send({
    type: 'broadcast', event: 'signal', payload: { ...msg, from: MY_ID, to }
  })
}

// ---- WebRTC ----
function createConnection(peer) {
  const pc = new RTCPeerConnection()
  const dc = pc.createDataChannel('chat')
  dc.onmessage = ev => {
    const d = JSON.parse(ev.data)
    appendIncoming(peer, d.text, d.isImage, d.ts, d.id)
  }
  dc.onopen = () => (dcMap[peer] = dc)
  pc.onicecandidate = e => {
  if (e.candidate)
    sendSignal(peer, { type: 'candidate', candidate: e.candidate, isCall: false });
};

  pcMap[peer] = pc
  makeOffer(peer)
}
async function makeOffer(peer) {
  const pc = pcMap[peer]
  const offer = await pc.createOffer()
  await pc.setLocalDescription(offer)
  sendSignal(peer, { type: 'offer', sdp: offer })
}
async function handleOffer(from, sdp) {
  const pc = new RTCPeerConnection()
  pc.ondatachannel = e => {
    const ch = e.channel
    ch.onmessage = ev => {
      const d = JSON.parse(ev.data)
      appendIncoming(from, d.text, d.isImage, d.ts, d.id)
    }
    ch.onopen = () => (dcMap[from] = ch)
  }
  pc.onicecandidate = e => e.candidate && sendSignal(from, { type: 'candidate', candidate: e.candidate })
  pcMap[from] = pc
  await pc.setRemoteDescription(new RTCSessionDescription(sdp))
  const answer = await pc.createAnswer()
  await pc.setLocalDescription(answer)
  sendSignal(from, { type: 'answer', sdp: answer })
}
async function handleAnswer(from, sdp) {
  await pcMap[from]?.setRemoteDescription(new RTCSessionDescription(sdp))
}
async function handleCandidate(from, candidate, isCall=false) {
  try {
    if (isCall) {
      if (callPC) await callPC.addIceCandidate(new RTCIceCandidate(candidate));
    } else {
      if (pcMap[from]) await pcMap[from].addIceCandidate(new RTCIceCandidate(candidate));
    }
  } catch (err) {
    console.warn('Failed to add ICE candidate', err);
  }
}


// ---- Drive Persistence ----
async function fetchDriveData() {
  try {
    const listRes = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${DRIVE_FILE_NAME}' and trashed=false&fields=files(id,name)`, {
      headers: { Authorization: 'Bearer ' + DRIVE_TOKEN }
    })
    const list = await listRes.json()
    DRIVE_FILE_ID = list.files?.[0]?.id
    if (DRIVE_FILE_ID) {
      const fileRes = await fetch(`https://www.googleapis.com/drive/v3/files/${DRIVE_FILE_ID}?alt=media`, {
        headers: { Authorization: 'Bearer ' + DRIVE_TOKEN }
      })
      if (fileRes.ok) {
        chatStore = await fileRes.json()
        renderContacts()
      }
    } else saveToDrive()
  } catch (e) { logout() }
}
async function saveToDrive() {
  try {
    const meta = { name: DRIVE_FILE_NAME, mimeType: 'application/json' }
    const form = new FormData()
    form.append('metadata', new Blob([JSON.stringify(meta)], { type: 'application/json' }))
    form.append('file', new Blob([JSON.stringify(chatStore)], { type: 'application/json' }))
    const url = DRIVE_FILE_ID
      ? `https://www.googleapis.com/upload/drive/v3/files/${DRIVE_FILE_ID}?uploadType=multipart`
      : `https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart`
    const res = await fetch(url, { method: DRIVE_FILE_ID ? 'PATCH' : 'POST', headers: { Authorization: 'Bearer ' + DRIVE_TOKEN }, body: form })
    if (res.ok) DRIVE_FILE_ID = (await res.json()).id
  } catch { logout() }
}
function logout() { localStorage.removeItem(STORAGE_KEY); location.href = 'register.html' }

// ---- Status Updates ----
function updatePeerStatus(id) {
  peerStatusEl.textContent = online[id] ? 'Online' :
    chatStore[id]?.lastSeen ? 'Last seen at ' + new Date(chatStore[id].lastSeen).toLocaleTimeString() : 'Offline'
}

// ---- Init ----
searchEl.oninput = () => renderContacts(searchEl.value.trim())
addBtn.onclick = () => {
  renderOnlineDialog();
};

logoutBtn.onclick = logout
sendBtn.onclick = sendMessage
messageInput.onkeydown = e => {
  if (!currentPeer) return
  if (e.key === 'Enter') sendMessage()
  else sendTypingSignal()
}
function renderOnlineDialog() {
  const dialog = document.getElementById('onlineDialog');
  const list = document.getElementById('onlineList');
  const closeBtn = document.getElementById('closeDialog');
  list.innerHTML = '';

  const onlineUsers = Object.values(chatStore)
    .map(c => c.profile)
    .filter(p => online[p.uuid] && p.uuid !== MY_ID);

  if (onlineUsers.length === 0) {
    list.innerHTML = `<div style="text-align:center;color:#64748b;padding:20px">No one online</div>`;
  } else {
    for (const u of onlineUsers) {
      const div = document.createElement('div');
      div.className = 'dialog-user';
      div.innerHTML = `
        <img src="${u.avatar}">
        <span>${u.name}</span>
      `;
      div.onclick = () => {
        dialog.style.display = 'none';
        if (!chatStore[u.uuid])
          chatStore[u.uuid] = { profile: u, messages: [], unreadCount: 0 };
        openChat(u.uuid);
      };
      list.appendChild(div);
    }
  }

  dialog.style.display = 'flex';
  closeBtn.onclick = () => dialog.style.display = 'none';
}

function sendTypingSignal() {
  if (!currentPeer) return
  clearTimeout(typingTimeout[currentPeer])
  sendSignal(currentPeer, { type: 'typing' })
  typingTimeout[currentPeer] = setTimeout(() => {
    sendSignal(currentPeer, { type: 'stopTyping' })
  }, 3000)
}

startRealtime() 
</script> 
</body>
</html>















