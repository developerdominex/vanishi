<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hybrid â€” Chat</title>
<link rel="icon" href="hybrid.png" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<style>
:root{
  --bg:#e6eefc;
  --side:#ffffff;
  --card:#ffffff;
  --primary:#2b9cff;
  --primary-600:#257ed6;
  --muted:#6b7280;
  --shadow:0 12px 30px rgba(16,24,40,0.08);
  --radius:14px;
}
*{box-sizing:border-box;margin:0;padding:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,'Helvetica Neue',Arial;}
html,body{height:100%;overflow:hidden;}
body{
  background:linear-gradient(180deg,#f6fbff 0%,#e6eefc 100%);
  display:flex;align-items:center;justify-content:center;
  height:100vh;overflow:hidden;padding:24px;
}
.app{
  width:100%;max-width:1100px;
  height:100%;max-height:800px;
  display:grid;grid-template-columns:320px 1fr;gap:20px;
}
.panel{
  background:var(--side);border-radius:var(--radius);
  box-shadow:var(--shadow);
  display:flex;flex-direction:column;overflow:hidden;
}
.panel .header{padding:18px 16px;display:flex;align-items:center;gap:12px;border-bottom:1px solid rgba(15,23,42,0.04);}
.panel .title{font-weight:700;color:#0f172a;font-size:16px;}
.panel .subtitle{color:var(--muted);font-size:12px;margin-top:4px;}
.search{padding:12px 14px;border-bottom:1px solid rgba(15,23,42,0.04);display:flex;gap:8px;align-items:center;}
.search input{flex:1;border-radius:12px;padding:10px 12px;border:1px solid rgba(15,23,42,0.06);outline:none;background:#fbfdff;font-size:14px;color:#071133;transition:box-shadow .18s ease;}
.search input:focus{box-shadow:0 6px 18px rgba(43,156,255,0.12);border-color:var(--primary-600);}
.list{padding:12px;flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:8px;scroll-behavior:smooth;}
.contact{display:flex;align-items:center;gap:12px;padding:10px;border-radius:12px;cursor:pointer;transition:background .12s ease,transform .12s ease;}
.contact:hover{background:rgba(43,156,255,0.04);transform:translateY(-2px);}
.contact.selected{background:linear-gradient(90deg,var(--primary) 0%,var(--primary-600) 100%);color:white;box-shadow:0 10px 30px rgba(43,156,255,0.12);}
.avatar{width:48px;height:48px;border-radius:50%;object-fit:cover;box-shadow:0 6px 18px rgba(2,6,23,0.06);}
.meta{display:flex;flex-direction:column;gap:4px;min-width:0;}
.meta .name{font-weight:600;font-size:15px;color:#071133;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.contact.selected .name{color:white;}
.meta .last{color:var(--muted);font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.contact.selected .last{color:rgba(255,255,255,0.9);}
.chat{
  background:linear-gradient(180deg,#ffffff,#f7fbff);
  border-radius:var(--radius);box-shadow:var(--shadow);
  display:flex;flex-direction:column;overflow:hidden;
}
.chat .top{padding:14px 18px;display:flex;align-items:center;gap:12px;border-bottom:1px solid rgba(15,23,42,0.04);}
.chat .top img{width:44px;height:44px;border-radius:50%;object-fit:cover;}
.chat .who{display:flex;flex-direction:column;}
.chat .n{font-weight:700;color:#071133;}
.chat .s{font-size:13px;color:var(--muted);}
.chat .body{
  flex:1;overflow-y:auto;
  padding:20px;display:flex;flex-direction:column;
  background:linear-gradient(180deg,#f7fbff00,#ffffff00);
  scroll-behavior:smooth;
  min-height:0; 
}
.messages{
  display:flex;flex-direction:column;gap:8px;
  width:100%;margin-top:auto;margin-bottom:auto;
}
.msg{display:inline-block;max-width:72%;padding:12px 14px;border-radius:18px;font-size:15px;line-height:1.3;box-shadow:0 6px 20px rgba(2,6,23,0.06);opacity:0;transform:translateY(8px);animation:pop .22s ease forwards;}
@keyframes pop{to{opacity:1;transform:none;}}
.msg.me{background:linear-gradient(180deg,var(--primary),var(--primary-600));color:white;align-self:flex-end;border-bottom-right-radius:6px;}
.msg.other{background:#fff;color:#071133;align-self:flex-start;border-bottom-left-radius:6px;}
.msg img{max-width:300px;border-radius:12px;display:block;}
.placeholder{display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:15px;}
.composer{
  padding:12px;border-top:1px solid rgba(15,23,42,0.04);
  display:flex;gap:8px;align-items:center;
  background:linear-gradient(180deg,#ffffff,#f7fbff);
}
.input{flex:1;background:#f3f6ff;padding:10px 14px;border-radius:999px;display:flex;gap:8px;align-items:center;box-shadow:inset 0 1px 0 rgba(255,255,255,0.6);}
.input input{flex:1;border:none;background:transparent;outline:none;font-size:15px;color:#071133;}
.icon-btn{width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:pointer;border:none;background:transparent;color:var(--primary);font-size:18px;}
.send{width:48px;height:44px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--primary),var(--primary-600));color:white;font-size:18px;border:none;cursor:pointer;box-shadow:0 10px 24px rgba(43,156,255,0.14);}
.typing-indicator {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: #ffffff;
  color: #0b132b;
  padding: 8px 12px;
  border-radius: 16px;
  box-shadow: 0 2px 10px rgba(11, 19, 43, 0.08);
  margin: 2px 0;
  max-width: 85%;
  animation: fadeInUp 0.25s cubic-bezier(.4,0,.2,1) forwards;
  transform-origin: bottom;
}
.typing-indicator.me {
  background: var(--primary, #3b82f6);
  color: #fff;
  align-self: flex-end;
}
.typing-indicator span.label {
  font-size: 0.85rem;
  font-weight: 500;
  white-space: nowrap;
}
.typing-dots {
  display: flex;
  gap: 4px;
}
.typing-dots span {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: currentColor;
  opacity: 0.3;
  animation: typingBounce 1.2s infinite ease-in-out;
}
.typing-dots span:nth-child(2) { animation-delay: 0.15s; }
.typing-dots span:nth-child(3) { animation-delay: 0.3s; }

@keyframes typingBounce {
  0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }
  40% { transform: translateY(-4px); opacity: 1; }
}

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(6px) scale(0.96); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}

@media (max-width:900px){
  body{padding:12px;}
  .app{grid-template-columns:1fr;gap:12px;max-width:720px;height:100%;max-height:none;}
  .panel{order:2;min-height:35vh;max-height:40vh;border-radius:12px;overflow-y:auto;}
  .chat{order:1;min-height:55vh;max-height:65vh;display:flex;flex-direction:column;}
  .chat .body{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;scroll-behavior:smooth;}
  .messages{margin-bottom:auto;}
}
</style>

</head>
<body>
<div class="app" id="app">
  <div class="panel" id="sidebar">
    <div class="header">
      <div style="display:flex;flex-direction:column">
        <div class="title">Hybrid</div>
        <div class="subtitle">messaging</div>
      </div>
    </div>
    <div class="search">
      <input id="search" placeholder="Search people or paste id..." autocomplete="off">
      <button class="icon-btn" id="addBtn" title="Add by ID"><i class="fas fa-user-plus"></i></button>
    </div>
    <div class="list" id="contacts"></div>
    <div style="padding:12px;border-top:1px dashed rgba(15,23,42,0.04);display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div style="display:flex;gap:8px;align-items:center">
        <img id="myAvatar" src="" style="width:42px;height:42px;border-radius:50%;object-fit:cover">
        <div style="font-size:13px;color:#071133;font-weight:600" id="myName"></div>
      </div>
      <button id="logout" class="icon-btn" style="background:#fff;color:#ef4444;border-radius:10px;"><i class="fas fa-right-from-bracket"></i></button>
    </div>
  </div>
  <div class="chat" id="chat">
    <div class="top">
      <img id="peerAvatar" src="" alt="avatar" style="display:none">
      <div class="who">
        <div class="n" id="peerName">Select a contact</div>
        <div class="s" id="peerStatus"></div>
      </div>
    </div>
    <div class="body" id="chatBody">
      <div class="placeholder" id="placeholder">Select a contact to start chatting.</div>
      <div class="messages" id="messages" style="display:none"></div>
    </div>
    <div class="composer">
      <div class="input">
        <input id="messageInput" placeholder="Type a message..." autocomplete="off">
      </div>
      <button class="icon-btn" id="attach"><i class="fas fa-paperclip"></i></button>
      <button class="send" id="sendBtn"><i class="fas fa-paper-plane"></i></button>
    </div>
  </div>
</div>

<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

// ---- Supabase Setup ----
const SUPABASE_URL = 'https://dfzshvldanqfvfivjrqi.supabase.co'
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRmenNodmxkYW5xZnZmaXZqcnFpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ4MDIxNTEsImV4cCI6MjA3MDM3ODE1MX0.wdms-6G9eDzRuk1YiCpdyvVS-5CRKCsrq9WWWIFl9HA'
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

// ---- Google Drive Config ----
const DRIVE_FILE_NAME = 'chat.json'
const STORAGE_KEY = 'hc_profile'
const profile = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null')
if (!profile) { location.href = 'register.html'; throw new Error('No profile') }

const MY_ID = profile.id
const MY_NAME = profile.name
const MY_AVATAR = profile.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(profile.name)}`
const DRIVE_TOKEN = profile.token

// ---- Elements ----
const contactsEl = document.getElementById('contacts')
const searchEl = document.getElementById('search')
const addBtn = document.getElementById('addBtn')
const logoutBtn = document.getElementById('logout')
const peerAvatarEl = document.getElementById('peerAvatar')
const peerNameEl = document.getElementById('peerName')
const peerStatusEl = document.getElementById('peerStatus')
const placeholderEl = document.getElementById('placeholder')
const messagesEl = document.getElementById('messages')
const messageInput = document.getElementById('messageInput')
const sendBtn = document.getElementById('sendBtn')
const attachBtn = document.getElementById('attach')
document.getElementById('myAvatar').src = MY_AVATAR
document.getElementById('myName').textContent = MY_NAME

// ---- Data ----
let chatStore = {}
let online = {}
let currentPeer = null
let DRIVE_FILE_ID = null
let typingTimeout = {}
let pcMap = {}, dcMap = {}
const typingIndicators = {}

function showTyping(peerId) {
  if (typingIndicators[peerId]) return 
  const d = document.createElement('div')
  d.className = 'typing-indicator'
  d.innerHTML = `<span>${chatStore[peerId]?.profile?.name || 'User'} is typing</span>
  <div class="typing-dots"><span></span><span></span><span></span></div>`
  d.id = `typing-${peerId}`
  messagesEl.appendChild(d)
  typingIndicators[peerId] = d
  scrollBottom()
}

function hideTyping(peerId) {
  const el = typingIndicators[peerId]
  if (el) {
    el.style.opacity = 0
    el.style.transform = "translateY(6px)"
    setTimeout(() => el.remove(), 250)
    delete typingIndicators[peerId]
  }
}

// ---- UI: Contacts ----
function renderContacts(filter = '') {
  contactsEl.innerHTML = ''
  const sorted = Object.values(chatStore)
    .sort((a, b) => (b.lastTs || 0) - (a.lastTs || 0))
    .filter(c => !filter || c.profile.name.toLowerCase().includes(filter.toLowerCase()))

  for (const c of sorted) {
    const u = c.profile
    const lastMsg = c.messages.slice(-1)[0]
    const unread = c.unreadCount > 0
    const div = document.createElement('div')
    div.className = 'contact' + (currentPeer === u.uuid ? ' selected' : '')
    div.innerHTML = `
      <img class="avatar" src="${u.avatar}">
      <div class="meta">
        <div class="name" style="font-weight:${unread ? '700' : '500'}">${u.name}</div>
        <div class="last">${lastMsg ? (lastMsg.isImage ? 'ðŸ“· Image' : lastMsg.text) : 'No messages yet'}</div>
      </div>`
    div.onclick = () => openChat(u.uuid)
    contactsEl.appendChild(div)
  }
}

// ---- Open Chat ----
function openChat(peerId) {
  currentPeer = peerId
  const peer = chatStore[peerId].profile
  chatStore[peerId].unreadCount = 0
  peerNameEl.textContent = peer.name
  peerAvatarEl.src = peer.avatar
  peerAvatarEl.style.display = 'block'
  updatePeerStatus(peerId)

  placeholderEl.style.display = 'none'
  messagesEl.style.display = 'flex'
  messagesEl.innerHTML = ''

  for (const msg of chatStore[peerId].messages)
    renderMessage(msg.text, msg.me, msg.isImage, false)

  if (!pcMap[peerId]) createConnection(peerId)
  saveToDrive()
  renderContacts()
  scrollBottom()
}

// ---- Messages ----
function renderMessage(text, me, isImage, animate = true) {
  const d = document.createElement('div')
  d.className = 'msg ' + (me ? 'me' : 'other')
  if (isImage) {
    const img = document.createElement('img')
    img.src = text
    d.appendChild(img)
  } else d.textContent = text
  messagesEl.appendChild(d)
  if (animate) d.style.opacity = 0, requestAnimationFrame(() => d.style.opacity = 1)
  scrollBottom()
}
function scrollBottom() { messagesEl.scrollTop = messagesEl.scrollHeight }

function sendMessage() {
  if (!currentPeer) return
  const val = messageInput.value.trim()
  if (!val) return
  const ts = Date.now()
  const msg = { id: ts + '-me', text: val, ts, me: true, isImage: false }
  chatStore[currentPeer].messages.push(msg)
  chatStore[currentPeer].lastTs = ts
  renderMessage(val, true, false)
  messageInput.value = ''

  // Send via data channel or fallback
  const payload = { text: val, ts, id: msg.id, isImage: false }
  if (dcMap[currentPeer]?.readyState === 'open')
    dcMap[currentPeer].send(JSON.stringify(payload))
  else
    sendSignal(currentPeer, { type: 'message', data: val, ts, id: msg.id, isImage: false })

  saveToDrive()
  renderContacts()
}

// ---- Incoming Message ----
function appendIncoming(from, text, isImage, ts, id) {
  hideTyping(from)
  const chat = chatStore[from] || (chatStore[from] = { profile: { uuid: from, name: 'User', avatar: `https://ui-avatars.com/api/?name=User` }, messages: [], unreadCount: 0 })
  if (chat.messages.some(m => m.id === id)) return
  chat.messages.push({ id, text, me: false, isImage, ts })
  chat.lastTs = ts
  if (currentPeer === from) renderMessage(text, false, isImage)
  else chat.unreadCount++
  renderContacts()
  saveToDrive()
}
attachBtn.onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = async e => {
    const f = e.target.files[0];
    if (!f) return;
    const dataUrl = await resizeAndCompress(f, 200, 200, 0.3, 25); // target 25KB
    sendImageMessage(dataUrl);
  };
  input.click();
};

async function resizeAndCompress(file, maxWidth, maxHeight, initialQuality = 0.3, targetKB = 25) {
  return new Promise((resolve) => {
    const img = new Image();
    const reader = new FileReader();
    reader.onload = e => img.src = e.target.result;
    img.onload = () => {
      let { width, height } = img;

      // maintain aspect ratio
      const scale = Math.min(maxWidth / width, maxHeight / height, 1);
      width = width * scale;
      height = height * scale;

      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, width, height);

      let quality = initialQuality;
      let compressed = canvas.toDataURL('image/jpeg', quality);
      let sizeKB = Math.round((compressed.length * 3 / 4) / 1024);

      // reduce quality in small steps until < targetKB
      while (sizeKB > targetKB && quality > 0.05) {
        quality -= 0.05;
        compressed = canvas.toDataURL('image/jpeg', quality);
        sizeKB = Math.round((compressed.length * 3 / 4) / 1024);
      }

      resolve(compressed);
    };
    reader.readAsDataURL(file);
  });
}



function sendImageMessage(dataUrl) {
  if (!currentPeer) return
  const ts = Date.now()
  const msg = { id: ts + '-me', text: dataUrl, ts, me: true, isImage: true }
  chatStore[currentPeer].messages.push(msg)
  chatStore[currentPeer].lastTs = ts
  renderMessage(dataUrl, true, true)

  const payload = { text: dataUrl, ts, id: msg.id, isImage: true }
  if (dcMap[currentPeer]?.readyState === 'open')
    dcMap[currentPeer].send(JSON.stringify(payload))
  else sendSignal(currentPeer, { type: 'message', data: dataUrl, ts, id: msg.id, isImage: true })

  saveToDrive()
  renderContacts()
}

// ---- Supabase Presence & Signaling ----
async function startRealtime() {
  const presence = supabase.channel('presence')
  const signaling = supabase.channel('signaling')

  presence.on('broadcast', { event: 'presence' }, ({ payload }) => {
    if (!payload?.uuid) return
    if (payload.action === 'join' || payload.action === 'update') {
      online[payload.uuid] = true
      chatStore[payload.uuid] = chatStore[payload.uuid] || { profile: payload, messages: [], unreadCount: 0 }
    } else if (payload.action === 'leave') {
      online[payload.uuid] = false
      chatStore[payload.uuid].lastSeen = Date.now()
    }
    renderContacts()
    if (payload.uuid === currentPeer) updatePeerStatus(currentPeer)
  })

  signaling.on('broadcast', { event: 'signal' }, async ({ payload }) => {
    if (!payload || payload.to !== MY_ID) return
    if (payload.type === 'offer') await handleOffer(payload.from, payload.sdp)
    else if (payload.type === 'answer') await handleAnswer(payload.from, payload.sdp)
    else if (payload.type === 'candidate') await handleCandidate(payload.from, payload.candidate)
    else if (payload.type === 'message') appendIncoming(payload.from, payload.data, payload.isImage, payload.ts, payload.id)
    else if (payload.type === 'typing') {
  if (payload.from === currentPeer) showTyping(payload.from)
}
else if (payload.type === 'stopTyping') {
  hideTyping(payload.from)
}

  })

  await presence.subscribe()
  await signaling.subscribe()
  setInterval(() => sendPresence('update'), 25000)
  window.addEventListener('beforeunload', () => sendPresence('leave'))
  sendPresence('join')

  await fetchDriveData()
}

function sendPresence(action) {
  supabase.channel('presence').send({
    type: 'broadcast', event: 'presence',
    payload: { uuid: MY_ID, name: MY_NAME, avatar: MY_AVATAR, action, ts: Date.now() }
  })
}
function sendSignal(to, msg) {
  supabase.channel('signaling').send({
    type: 'broadcast', event: 'signal', payload: { ...msg, from: MY_ID, to }
  })
}

// ---- WebRTC ----
function createConnection(peer) {
  const pc = new RTCPeerConnection()
  const dc = pc.createDataChannel('chat')
  dc.onmessage = ev => {
    const d = JSON.parse(ev.data)
    appendIncoming(peer, d.text, d.isImage, d.ts, d.id)
  }
  dc.onopen = () => (dcMap[peer] = dc)
  pc.onicecandidate = e => e.candidate && sendSignal(peer, { type: 'candidate', candidate: e.candidate })
  pcMap[peer] = pc
  makeOffer(peer)
}
async function makeOffer(peer) {
  const pc = pcMap[peer]
  const offer = await pc.createOffer()
  await pc.setLocalDescription(offer)
  sendSignal(peer, { type: 'offer', sdp: offer })
}
async function handleOffer(from, sdp) {
  const pc = new RTCPeerConnection()
  pc.ondatachannel = e => {
    const ch = e.channel
    ch.onmessage = ev => {
      const d = JSON.parse(ev.data)
      appendIncoming(from, d.text, d.isImage, d.ts, d.id)
    }
    ch.onopen = () => (dcMap[from] = ch)
  }
  pc.onicecandidate = e => e.candidate && sendSignal(from, { type: 'candidate', candidate: e.candidate })
  pcMap[from] = pc
  await pc.setRemoteDescription(new RTCSessionDescription(sdp))
  const answer = await pc.createAnswer()
  await pc.setLocalDescription(answer)
  sendSignal(from, { type: 'answer', sdp: answer })
}
async function handleAnswer(from, sdp) {
  await pcMap[from]?.setRemoteDescription(new RTCSessionDescription(sdp))
}
async function handleCandidate(from, candidate) {
  await pcMap[from]?.addIceCandidate(new RTCIceCandidate(candidate))
}

// ---- Drive Persistence ----
async function fetchDriveData() {
  try {
    const listRes = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${DRIVE_FILE_NAME}' and trashed=false&fields=files(id,name)`, {
      headers: { Authorization: 'Bearer ' + DRIVE_TOKEN }
    })
    const list = await listRes.json()
    DRIVE_FILE_ID = list.files?.[0]?.id
    if (DRIVE_FILE_ID) {
      const fileRes = await fetch(`https://www.googleapis.com/drive/v3/files/${DRIVE_FILE_ID}?alt=media`, {
        headers: { Authorization: 'Bearer ' + DRIVE_TOKEN }
      })
      if (fileRes.ok) {
        chatStore = await fileRes.json()
        renderContacts()
      }
    } else saveToDrive()
  } catch (e) { logout() }
}
async function saveToDrive() {
  try {
    const meta = { name: DRIVE_FILE_NAME, mimeType: 'application/json' }
    const form = new FormData()
    form.append('metadata', new Blob([JSON.stringify(meta)], { type: 'application/json' }))
    form.append('file', new Blob([JSON.stringify(chatStore)], { type: 'application/json' }))
    const url = DRIVE_FILE_ID
      ? `https://www.googleapis.com/upload/drive/v3/files/${DRIVE_FILE_ID}?uploadType=multipart`
      : `https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart`
    const res = await fetch(url, { method: DRIVE_FILE_ID ? 'PATCH' : 'POST', headers: { Authorization: 'Bearer ' + DRIVE_TOKEN }, body: form })
    if (res.ok) DRIVE_FILE_ID = (await res.json()).id
  } catch { logout() }
}
function logout() { localStorage.removeItem(STORAGE_KEY); location.href = 'register.html' }

// ---- Status Updates ----
function updatePeerStatus(id) {
  peerStatusEl.textContent = online[id] ? 'Online' :
    chatStore[id]?.lastSeen ? 'Last seen ' + new Date(chatStore[id].lastSeen).toLocaleTimeString() : 'Offline'
}

// ---- Init ----
searchEl.oninput = () => renderContacts(searchEl.value.trim())
addBtn.onclick = () => {
  const id = searchEl.value.trim()
  if (!id || id === MY_ID) return
  if (!chatStore[id])
    chatStore[id] = { profile: { uuid: id, name: 'User', avatar: `https://ui-avatars.com/api/?name=User` }, messages: [], unreadCount: 0 }
  saveToDrive(); renderContacts()
}
logoutBtn.onclick = logout
sendBtn.onclick = sendMessage
messageInput.onkeydown = e => {
  if (!currentPeer) return
  if (e.key === 'Enter') sendMessage()
  else sendTypingSignal()
}

function sendTypingSignal() {
  if (!currentPeer) return
  clearTimeout(typingTimeout[currentPeer])
  sendSignal(currentPeer, { type: 'typing' })
  typingTimeout[currentPeer] = setTimeout(() => {
    sendSignal(currentPeer, { type: 'stopTyping' })
  }, 3000)
}

startRealtime()
</script> 
</body>
</html>










