<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hybrid â€” Chat</title>
<link rel="icon" href="hybrid.png" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<style>
:root{
  --bg:#e6eefc;
  --side:#ffffff;
  --card:#ffffff;
  --primary:#2b9cff;
  --primary-600:#257ed6;
  --muted:#6b7280;
  --shadow:0 12px 30px rgba(16,24,40,0.08);
  --radius:14px;
}
*{box-sizing:border-box;margin:0;padding:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,'Helvetica Neue',Arial;}
html,body{height:100%;overflow:hidden;}
body{
  background:linear-gradient(180deg,#f6fbff 0%,#e6eefc 100%);
  display:flex;align-items:center;justify-content:center;
  height:100vh;overflow:hidden;padding:24px;
}
.app{
  width:100%;max-width:1100px;
  height:100%;max-height:800px;
  display:grid;grid-template-columns:320px 1fr;gap:20px;
}
  .custom-dialog {
  position: fixed;
  top:0; left:0; right:0; bottom:0;
  display:flex;
  justify-content:center;
  align-items:center;
  background: rgba(0,0,0,0.4);
  z-index:99999;
  opacity:0;
  pointer-events:none;
  transition: opacity 0.2s ease;
}
.custom-dialog.show {
  opacity:1;
  pointer-events:auto;
}
.custom-dialog-content {
  background:#fff;
  padding:20px;
  border-radius:16px;
  min-width:260px;
  max-width:90vw;
  text-align:center;
  box-shadow:0 8px 24px rgba(0,0,0,0.2);
  animation: popIn 0.25s ease;
}
.custom-dialog-buttons {
  margin-top:15px;
  display:flex;
  justify-content:center;
  gap:12px;
}
.custom-dialog-buttons button {
  padding:6px 12px;
  border:none;
  border-radius:8px;
  cursor:pointer;
  font-weight:600;
  transition:0.2s;
}
.custom-dialog-buttons button:hover { transform:scale(1.05); }
.custom-dialog-buttons .primary { background:#ef4444; color:#fff; }
.custom-dialog-buttons .secondary { background:#e5e7eb; color:#111; }

@keyframes popIn { from {transform:scale(0.8); opacity:0} to {transform:scale(1); opacity:1} }
.panel{
  background:var(--side);border-radius:var(--radius);
  box-shadow:var(--shadow);
  display:flex;flex-direction:column;overflow:hidden;
}
.panel .header{padding:18px 16px;display:flex;align-items:center;gap:12px;border-bottom:1px solid rgba(15,23,42,0.04);}
.panel .title{font-weight:700;color:#0f172a;font-size:16px;}
.panel .subtitle{color:var(--muted);font-size:12px;margin-top:4px;}
.search{padding:12px 14px;border-bottom:1px solid rgba(15,23,42,0.04);display:flex;gap:8px;align-items:center;}
.search input{flex:1;border-radius:12px;padding:10px 12px;border:1px solid rgba(15,23,42,0.06);outline:none;background:#fbfdff;font-size:14px;color:#071133;transition:box-shadow .18s ease;}
.search input:focus{box-shadow:0 6px 18px rgba(43,156,255,0.12);border-color:var(--primary-600);}
.list{padding:12px;flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:8px;scroll-behavior:smooth;}
.contact{display:flex;align-items:center;gap:12px;padding:10px;border-radius:12px;cursor:pointer;transition:background .12s ease,transform .12s ease;}
.contact:hover{background:rgba(43,156,255,0.04);transform:translateY(-2px);}
.contact.selected{background:linear-gradient(90deg,var(--primary) 0%,var(--primary-600) 100%);color:white;box-shadow:0 10px 30px rgba(43,156,255,0.12);}
.avatar{width:48px;height:48px;border-radius:50%;object-fit:cover;box-shadow:0 6px 18px rgba(2,6,23,0.06);}
.meta{display:flex;flex-direction:column;gap:4px;min-width:0;}
.meta .name{font-weight:600;font-size:15px;color:#071133;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.contact.selected .name{color:white;}
.meta .last{color:var(--muted);font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.contact.selected .last{color:rgba(255,255,255,0.9);}
.chat{
  background:linear-gradient(180deg,#ffffff,#f7fbff);
  border-radius:var(--radius);box-shadow:var(--shadow);
  display:flex;flex-direction:column;overflow:hidden;
}
.chat .top{padding:14px 18px;display:flex;align-items:center;gap:12px;border-bottom:1px solid rgba(15,23,42,0.04);}
.chat .top img{width:44px;height:44px;border-radius:50%;object-fit:cover;}
.chat .who{display:flex;flex-direction:column;}
.chat .n{font-weight:700;color:#071133;}
.chat .s{font-size:13px;color:var(--muted);}
.chat .body{
  flex:1;overflow-y:auto;
  padding:20px;display:flex;flex-direction:column;
  background:linear-gradient(180deg,#f7fbff00,#ffffff00);
  scroll-behavior:smooth;
  min-height:0; 
}
.messages{
  display:flex;flex-direction:column;gap:8px;
  width:100%;margin-top:auto;margin-bottom:auto;
}
.msg{display:inline-block;max-width:72%;padding:12px 14px;border-radius:18px;font-size:15px;line-height:1.3;box-shadow:0 6px 20px rgba(2,6,23,0.06);opacity:0;transform:translateY(8px);animation:pop .22s ease forwards;}
@keyframes pop{to{opacity:1;transform:none;}}
.msg.me{background:linear-gradient(180deg,var(--primary),var(--primary-600));color:white;align-self:flex-end;border-bottom-right-radius:6px;}
.msg.other{background:#fff;color:#071133;align-self:flex-start;border-bottom-left-radius:6px;}
.msg img{max-width:300px;border-radius:12px;display:block;}
.placeholder{display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:15px;}
.composer{
  padding:12px;border-top:1px solid rgba(15,23,42,0.04);
  display:flex;gap:8px;align-items:center;
  background:linear-gradient(180deg,#ffffff,#f7fbff);
}
.input{flex:1;background:#f3f6ff;padding:10px 14px;border-radius:999px;display:flex;gap:8px;align-items:center;box-shadow:inset 0 1px 0 rgba(255,255,255,0.6);}
.input input{flex:1;border:none;background:transparent;outline:none;font-size:15px;color:#071133;}
.icon-btn{width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:pointer;border:none;background:transparent;color:var(--primary);font-size:18px;}
.send{width:48px;height:44px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--primary),var(--primary-600));color:white;font-size:18px;border:none;cursor:pointer;box-shadow:0 10px 24px rgba(43,156,255,0.14);}
.typing-indicator {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: #ffffff;
  color: #0b132b;
  padding: 8px 12px;
  border-radius: 16px;
  box-shadow: 0 2px 10px rgba(11, 19, 43, 0.08);
  margin: 2px 0;
  max-width: 85%;
  animation: fadeInUp 0.25s cubic-bezier(.4,0,.2,1) forwards;
  transform-origin: bottom;
}
.typing-indicator.me {
  background: var(--primary, #3b82f6);
  color: #fff;
  align-self: flex-end;
}
.typing-indicator span.label {
  font-size: 0.85rem;
  font-weight: 500;
  white-space: nowrap;
}
.typing-dots {
  display: flex;
  gap: 4px;
}
.typing-dots span {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: currentColor;
  opacity: 0.3;
  animation: typingBounce 1.2s infinite ease-in-out;
}
.typing-dots span:nth-child(2) { animation-delay: 0.15s; }
.typing-dots span:nth-child(3) { animation-delay: 0.3s; }

@keyframes typingBounce {
  0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }
  40% { transform: translateY(-4px); opacity: 1; }
}

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(6px) scale(0.96); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}

@media (max-width:900px){
  body{padding:12px;}
  .app{grid-template-columns:1fr;gap:12px;max-width:720px;height:100%;max-height:none;}
  .panel{order:2;min-height:35vh;max-height:40vh;border-radius:12px;overflow-y:auto;}
  .chat{order:1;min-height:55vh;max-height:65vh;display:flex;flex-direction:column;}
  .chat .body{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;scroll-behavior:smooth;}
  .messages{margin-bottom:auto;}
}
  .chat-actions {
  margin-left: auto;
  display: flex;
  gap: 8px;
  align-items: center;
}
.dialog {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(15, 23, 42, 0.35);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 999;
}
.dialog-content {
  background: white;
  border-radius: 12px;
  width: 320px;
  max-height: 420px;
  overflow-y: auto;
  box-shadow: 0 10px 25px rgba(0,0,0,0.2);
  animation: fadeInUp 0.25s ease;
}
.dialog-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #e2e8f0;
}
.dialog-list {
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.dialog-user {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px;
  border-radius: 10px;
  background: #f8fafc;
  cursor: pointer;
  transition: 0.2s;
}
.dialog-user:hover {
  background: #e0f2fe;
  transform: scale(1.02);
}
.dialog-user img {
  width: 40px; height: 40px; border-radius: 50%; object-fit: cover;
}
.dialog-user span {
  font-weight: 500;
  color: #0f172a;
}
.call-dialog {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 320px;
  max-width: 90vw;
  background: #fff;
  border-radius: 16px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.2);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: fadeIn 0.3s ease;
  z-index: 9999;
}
.call-content { display:flex; flex-direction:column; }
.call-header { display:flex; justify-content:space-between; align-items:center; padding:8px 12px; background:#f3f4f6; font-weight:600; }
.call-video-container { display:flex; flex-direction:column; align-items:center; justify-content:center; background:#000; position:relative; }
.call-video { width: 100%; max-height:200px; background:#000; border-radius:12px; margin-top:6px; }
.call-controls { display:flex; justify-content:space-around; padding:8px; background:#f9fafb; }
.call-controls .icon-btn { background:#ef4444; color:#fff; border-radius:50%; padding:8px; transition:0.2s; }
.call-controls .icon-btn:hover { transform:scale(1.1); }
@keyframes fadeIn { from {opacity:0; transform:translateY(20px);} to {opacity:1; transform:translateY(0);} }
</style>

</head>
<body>
  <div id="customDialog" class="custom-dialog" style="display:none;">
  <div class="custom-dialog-content">
    <div class="custom-dialog-message" id="dialogMessage"></div>
    <div class="custom-dialog-buttons" id="dialogButtons"></div>
  </div>
</div>
  <div id="onlineDialog" class="dialog" style="display:none;">
  <div class="dialog-content">
    <div class="dialog-header">
      <h3>Online Users</h3>
      <button class="icon-btn" id="closeDialog"><i class="fas fa-times"></i></button>
    </div>
    <div id="onlineList" class="dialog-list"></div>
  </div>
</div>
  <div id="callDialog" class="call-dialog" style="display:none;">
  <div class="call-content">
    <div class="call-header">
      <span id="callPeerName">Calling...</span>
      <button class="icon-btn" id="endCallBtn"><i class="fas fa-phone-slash"></i></button>
    </div>
    <div class="call-video-container">
      <video id="localVideo" autoplay muted class="call-video"></video>
      <video id="remoteVideo" autoplay class="call-video"></video>
    </div>
    <div class="call-controls">
      <button id="muteMic" class="icon-btn"><i class="fas fa-microphone"></i></button>
      <button id="toggleCamera" class="icon-btn"><i class="fas fa-video"></i></button>
      <button id="hangUpBtn" class="icon-btn"><i class="fas fa-phone-slash"></i></button>
    </div>
  </div>
</div>
<div class="app" id="app">
  <div class="panel" id="sidebar">
    <div class="header">
      <div style="display:flex;flex-direction:column">
        <div class="title">Hybrid</div>
        <div class="subtitle">messaging</div>
      </div>
    </div>
    <div class="search">
      <input id="search" placeholder="Search people or paste id..." autocomplete="off">
      <button class="icon-btn" id="addBtn" title="Add by ID"><i class="fas fa-user-plus"></i></button>
    </div>
    <div class="list" id="contacts"></div>
    <div style="padding:12px;border-top:1px dashed rgba(15,23,42,0.04);display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div style="display:flex;gap:8px;align-items:center">
        <img id="myAvatar" src="" style="width:42px;height:42px;border-radius:50%;object-fit:cover">
        <div style="font-size:13px;color:#071133;font-weight:600" id="myName"></div>
      </div>
      <button id="logout" class="icon-btn" style="background:#fff;color:#ef4444;border-radius:10px;"><i class="fas fa-right-from-bracket"></i></button>
    </div>
  </div>
  <div class="chat" id="chat">
    <div class="top">
  <img id="peerAvatar" src="" alt="avatar" style="display:none">
  <div class="who">
    <div class="n" id="peerName">Select a contact</div>
    <div class="s" id="peerStatus"></div>
  </div>
  <div class="chat-actions" id="chatActions" style="display:none">
    <button class="icon-btn"><i class="fas fa-video"></i></button>
    <button class="icon-btn"><i class="fas fa-phone"></i></button>
  </div>
</div>

    <div class="body" id="chatBody">
      <div class="placeholder" id="placeholder">Select a contact to start chatting.</div>
      <div class="messages" id="messages" style="display:none"></div>
    </div>
    <div class="composer">
      <div class="input">
        <input id="messageInput" placeholder="Type a message..." autocomplete="off">
      </div>
      <button class="icon-btn" id="attach"><i class="fas fa-paperclip"></i></button>
      <button class="send" id="sendBtn"><i class="fas fa-paper-plane"></i></button>
    </div>
  </div>
</div>

<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

const SUPABASE_URL = 'https://dfzshvldanqfvfivjrqi.supabase.co'
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRmenNodmxkYW5xZnZmaXZqcnFpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ4MDIxNTEsImV4cCI6MjA3MDM3ODE1MX0.wdms-6G9eDzRuk1YiCpdyvVS-5CRKCsrq9WWWIFl9HA'
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

const DRIVE_FILE_NAME = 'chat.json'
const STORAGE_KEY = 'hc_profile'
const profile = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null')
if (!profile) { location.href = 'register.html'; throw new Error('No profile') }

const MY_ID = profile.id
const MY_NAME = profile.name
const MY_AVATAR = profile.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(profile.name)}`
const DRIVE_TOKEN = profile.token

const contactsEl = document.getElementById('contacts')
const searchEl = document.getElementById('search')
const addBtn = document.getElementById('addBtn')
const logoutBtn = document.getElementById('logout')
const peerAvatarEl = document.getElementById('peerAvatar')
const peerNameEl = document.getElementById('peerName')
const peerStatusEl = document.getElementById('peerStatus')
const placeholderEl = document.getElementById('placeholder')
const messagesEl = document.getElementById('messages')
const messageInput = document.getElementById('messageInput')
const sendBtn = document.getElementById('sendBtn')
const attachBtn = document.getElementById('attach')
document.getElementById('myAvatar').src = MY_AVATAR
document.getElementById('myName').textContent = MY_NAME

let chatStore = {}
let online = {}
let currentPeer = null
let DRIVE_FILE_ID = null
let typingTimeout = {}
let pcMap = {}, dcMap = {}
const typingIndicators = {}
let localStream = null;
let currentCallPeer = null;
let callPc = null;
let isCalling = false;

const callDialog = document.getElementById('callDialog')
const localVideo = document.getElementById('localVideo')
const remoteVideo = document.getElementById('remoteVideo')
const callPeerName = document.getElementById('callPeerName')
const endCallBtn = document.getElementById('endCallBtn')
const hangUpBtn = document.getElementById('hangUpBtn')
const muteMicBtn = document.getElementById('muteMic')
const toggleCameraBtn = document.getElementById('toggleCamera')

document.querySelector('.chat-actions i.fa-video').parentNode.onclick = () => startCall('video')
document.querySelector('.chat-actions i.fa-phone').parentNode.onclick = () => startCall('audio')

async function startCall(type) {
  if (!currentPeer) return await showCustomDialog("Select a contact first", 'alert')
  if (isCalling) return await showCustomDialog("You are already in a call", 'alert')
  if (online[currentPeer] === false) return await showCustomDialog("User is offline", 'alert')
  if (chatStore[currentPeer]?.busy) return await showCustomDialog("The person you are calling is busy.", 'alert')

  callPeerName.textContent = chatStore[currentPeer].profile.name
  callDialog.style.display = 'flex'
  isCalling = true
  chatStore[currentPeer].busy = true

  localStream = await navigator.mediaDevices.getUserMedia({
    video: type==='video',
    audio: true
  })
  localVideo.srcObject = localStream

  callPc = new RTCPeerConnection()
  localStream.getTracks().forEach(track => callPc.addTrack(track, localStream))
  
  callPc.ontrack = e => { remoteVideo.srcObject = e.streams[0] }
  callPc.onicecandidate = e => { if (e.candidate) sendSignal(currentPeer, { type:'candidate', candidate:e.candidate }) }

  const dc = callPc.createDataChannel('call')
  dc.onmessage = ev => handleCallSignal(JSON.parse(ev.data))

  const offer = await callPc.createOffer()
  await callPc.setLocalDescription(offer)
  sendSignal(currentPeer, { type: 'call-offer', sdp: offer, callType: type })
}

async function handleCallSignal(msg) {
  if (msg.type === 'call-offer') {
    if (isCalling) {
      sendSignal(msg.from, { type:'call-busy' })
      return
    }

    const accept = await showCustomDialog(`${chatStore[msg.from].profile.name} is calling you. Accept?`, 'confirm')
    if (!accept) return sendSignal(msg.from, { type:'call-reject' })

    callDialog.style.display = 'flex'
    callPeerName.textContent = chatStore[msg.from].profile.name
    isCalling = true
    currentCallPeer = msg.from
    chatStore[msg.from].busy = true

    localStream = await navigator.mediaDevices.getUserMedia({
      video: msg.callType === 'video',
      audio: true
    })
    localVideo.srcObject = localStream

    callPc = new RTCPeerConnection()
    localStream.getTracks().forEach(track => callPc.addTrack(track, localStream))
    callPc.ontrack = e => { remoteVideo.srcObject = e.streams[0] }
    callPc.onicecandidate = e => { if(e.candidate) sendSignal(msg.from, { type:'candidate', candidate:e.candidate }) }

    await callPc.setRemoteDescription(new RTCSessionDescription(msg.sdp))
    const answer = await callPc.createAnswer()
    await callPc.setLocalDescription(answer)
    sendSignal(msg.from, { type:'call-answer', sdp: answer })
  }

  else if (msg.type === 'call-answer') {
    await callPc.setRemoteDescription(new RTCSessionDescription(msg.sdp))
  }

  else if (msg.type === 'candidate') {
    await callPc.addIceCandidate(new RTCIceCandidate(msg.candidate))
  }

  else if (msg.type === 'call-busy') await showCustomDialog("The person you are calling is busy.", 'alert')
  else if (msg.type === 'call-reject') await showCustomDialog("The person rejected your call.", 'alert')
}

hangUpBtn.onclick = endCall
endCallBtn.onclick = endCall
muteMicBtn.onclick = () => {
  if (!localStream) return
  localStream.getAudioTracks()[0].enabled = !localStream.getAudioTracks()[0].enabled
  muteMicBtn.querySelector('i').classList.toggle('fa-microphone-slash')
}
toggleCameraBtn.onclick = () => {
  if (!localStream) return
  const videoTrack = localStream.getVideoTracks()[0]
  if (videoTrack) videoTrack.enabled = !videoTrack.enabled
  toggleCameraBtn.querySelector('i').classList.toggle('fa-video-slash')
}

function endCall() {
  if (callPc) callPc.close()
  if (localStream) localStream.getTracks().forEach(t => t.stop())
  callPc = null
  localStream = null
  isCalling = false
  if(currentCallPeer) chatStore[currentCallPeer].busy = false
  currentCallPeer = null
  callDialog.style.display = 'none'
}

function showTyping(peerId) {
  if (typingIndicators[peerId]) return;
  const name = chatStore[peerId]?.profile?.name || 'User';
  const d = document.createElement('div');
  d.className = 'typing-indicator';
  d.id = `typing-${peerId}`;
  d.innerHTML = `<span class="label">${name} is typing</span>
    <div class="typing-dots"><span></span><span></span><span></span></div>`;
  messagesEl.appendChild(d);
  typingIndicators[peerId] = d;
  requestAnimationFrame(() => scrollElementIntoView(d, true));
}
function hideTyping(peerId) {
  const el = typingIndicators[peerId];
  if (!el) return;
  el.style.transition = 'opacity .18s ease, transform .18s ease';
  el.style.opacity = '0';
  el.style.transform = 'translateY(8px)';
  setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 200);
  delete typingIndicators[peerId];
}

// ---- UI: Contacts ----
function renderContacts(filter = '') {
  contactsEl.innerHTML = ''
 
  const sorted = Object.values(chatStore)
  .filter(c => c.messages && c.messages.length > 0)
  .sort((a, b) => (b.lastTs || 0) - (a.lastTs || 0))
  .filter(c => !filter || c.profile.name.toLowerCase().includes(filter.toLowerCase()));
 if (sorted.length === 0) {
  contactsEl.innerHTML = `<div style="text-align:center;color:#64748b;padding:20px">No chats yet</div>`;
  return;
}
  for (const c of sorted) {
    const u = c.profile
    const lastMsg = c.messages.slice(-1)[0]
    const unread = c.unreadCount > 0
    const div = document.createElement('div')
    div.className = 'contact' + (currentPeer === u.uuid ? ' selected' : '')
    div.innerHTML = `
      <img class="avatar" src="${u.avatar}">
      <div class="meta">
        <div class="name" style="font-weight:${unread ? '700' : '500'}">${u.name}</div>
        <div class="last">${lastMsg ? (lastMsg.isImage ? 'ðŸ“· Image' : lastMsg.text) : 'No messages yet'}</div>
      </div>`
    div.onclick = () => openChat(u.uuid)
    contactsEl.appendChild(div)
  }
}

function openChat(peerId) {
  currentPeer = peerId
  const peer = chatStore[peerId].profile
  chatStore[peerId].unreadCount = 0
  peerNameEl.textContent = peer.name
  peerAvatarEl.src = peer.avatar
  peerAvatarEl.style.display = 'block'
  updatePeerStatus(peerId)
  document.getElementById('chatActions').style.display = 'flex';

  placeholderEl.style.display = 'none'
  messagesEl.style.display = 'flex'
  messagesEl.innerHTML = ''

  for (const msg of chatStore[peerId].messages)
    renderMessage(msg.text, msg.me, msg.isImage, false)

  if (!pcMap[peerId]) createConnection(peerId)
  saveToDrive()
  renderContacts()
  scrollBottom()
}

function renderMessage(text, me, isImage, animate = true) {
  const d = document.createElement('div');
  d.className = 'msg ' + (me ? 'me' : 'other');
  if (isImage) {
    const img = document.createElement('img');
    img.src = text;
    img.alt = 'Image message';
    img.style.opacity = '0';
    img.style.transition = 'opacity .25s ease';
    d.appendChild(img);
    messagesEl.appendChild(d);
    img.onload = () => {
      img.style.opacity = '1';
      requestAnimationFrame(() => scrollElementIntoView(d, true));
    };
    img.onerror = () => {
      img.style.opacity = '1';
      requestAnimationFrame(() => scrollElementIntoView(d, true));
    };
  } else {
    d.textContent = text;
    messagesEl.appendChild(d);
    if (animate) { d.style.opacity = 0; requestAnimationFrame(() => d.style.opacity = 1); }
    requestAnimationFrame(() => scrollElementIntoView(d, true));
  }
}
  function showCustomDialog(message, type='alert') {
  return new Promise(resolve => {
    const dialog = document.getElementById('customDialog')
    const msgEl = document.getElementById('dialogMessage')
    const buttonsEl = document.getElementById('dialogButtons')
    
    msgEl.textContent = message
    buttonsEl.innerHTML = ''

    if(type==='alert') {
      const okBtn = document.createElement('button')
      okBtn.textContent = 'OK'
      okBtn.className = 'primary'
      okBtn.onclick = () => { dialog.classList.remove('show'); resolve(true) }
      buttonsEl.appendChild(okBtn)
    } else if(type==='confirm') {
      const yesBtn = document.createElement('button')
      yesBtn.textContent = 'Yes'
      yesBtn.className = 'primary'
      yesBtn.onclick = () => { dialog.classList.remove('show'); resolve(true) }
      const noBtn = document.createElement('button')
      noBtn.textContent = 'No'
      noBtn.className = 'secondary'
      noBtn.onclick = () => { dialog.classList.remove('show'); resolve(false) }
      buttonsEl.appendChild(yesBtn)
      buttonsEl.appendChild(noBtn)
    }

    dialog.classList.add('show')
  })
}

function scrollElementIntoView(el, smooth = true) {
  try {
    el.scrollIntoView({ behavior: smooth ? 'smooth' : 'auto', block: 'end', inline: 'nearest' });
  } catch {
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
}
  function resetChatView() {
  placeholderEl.style.display = 'flex';
  messagesEl.style.display = 'none';
  document.getElementById('chatActions').style.display = 'none';
}
resetChatView();

function scrollBottom(smooth = true) {
  const last = messagesEl.lastElementChild;
  if (last) scrollElementIntoView(last, smooth);
  else messagesEl.scrollTop = messagesEl.scrollHeight;
}
function sendMessage() {
  if (!currentPeer) return
  const val = messageInput.value.trim()
  if (!val) return
  const ts = Date.now()
  const msg = { id: ts + '-me', text: val, ts, me: true, isImage: false }
  chatStore[currentPeer].messages.push(msg)
  chatStore[currentPeer].lastTs = ts
  renderMessage(val, true, false)
  messageInput.value = ''

  const payload = { text: val, ts, id: msg.id, isImage: false }
  if (dcMap[currentPeer]?.readyState === 'open')
    dcMap[currentPeer].send(JSON.stringify(payload))
  else
    sendSignal(currentPeer, { type: 'message', data: val, ts, id: msg.id, isImage: false })

  saveToDrive()
  renderContacts()
}

function appendIncoming(from, text, isImage, ts, id) {
  hideTyping(from)
  const chat = chatStore[from] || (chatStore[from] = { profile: { uuid: from, name: 'User', avatar: `https://ui-avatars.com/api/?name=User` }, messages: [], unreadCount: 0 })
  if (chat.messages.some(m => m.id === id)) return
  chat.messages.push({ id, text, me: false, isImage, ts })
  chat.lastTs = ts
  if (currentPeer === from) renderMessage(text, false, isImage)
  else chat.unreadCount++
  renderContacts()
  saveToDrive()
}
attachBtn.onclick = () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.onchange = async e => {
    const f = e.target.files[0];
    if (!f) return;
    const dataUrl = await resizeAndCompress(f, 200, 200, 0.3, 25); // target 25KB
    sendImageMessage(dataUrl);
  };
  input.click();
};

async function resizeAndCompress(file, maxWidth, maxHeight, initialQuality = 0.3, targetKB = 25) {
  return new Promise((resolve) => {
    const img = new Image();
    const reader = new FileReader();
    reader.onload = e => img.src = e.target.result;
    img.onload = () => {
      let { width, height } = img;

      // maintain aspect ratio
      const scale = Math.min(maxWidth / width, maxHeight / height, 1);
      width = width * scale;
      height = height * scale;

      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, width, height);

      let quality = initialQuality;
      let compressed = canvas.toDataURL('image/jpeg', quality);
      let sizeKB = Math.round((compressed.length * 3 / 4) / 1024);

      // reduce quality in small steps until < targetKB
      while (sizeKB > targetKB && quality > 0.05) {
        quality -= 0.05;
        compressed = canvas.toDataURL('image/jpeg', quality);
        sizeKB = Math.round((compressed.length * 3 / 4) / 1024);
      }

      resolve(compressed);
    };
    reader.readAsDataURL(file);
  });
}



function sendImageMessage(dataUrl) {
  if (!currentPeer) return
  const ts = Date.now()
  const msg = { id: ts + '-me', text: dataUrl, ts, me: true, isImage: true }
  chatStore[currentPeer].messages.push(msg)
  chatStore[currentPeer].lastTs = ts
  renderMessage(dataUrl, true, true)

  const payload = { text: dataUrl, ts, id: msg.id, isImage: true }
  if (dcMap[currentPeer]?.readyState === 'open')
    dcMap[currentPeer].send(JSON.stringify(payload))
  else sendSignal(currentPeer, { type: 'message', data: dataUrl, ts, id: msg.id, isImage: true })

  saveToDrive()
  renderContacts()
}

// ---- Supabase Presence & Signaling ----
async function startRealtime() {
  const presence = supabase.channel('presence')
  const signaling = supabase.channel('signaling')

  presence.on('broadcast', { event: 'presence' }, ({ payload }) => {
    if (!payload?.uuid) return
    if (payload.action === 'join' || payload.action === 'update') {
      online[payload.uuid] = true
      chatStore[payload.uuid] = chatStore[payload.uuid] || { profile: payload, messages: [], unreadCount: 0 }
    } else if (payload.action === 'leave') {
      online[payload.uuid] = false
      chatStore[payload.uuid].lastSeen = Date.now()
    }
    renderContacts()
    if (payload.uuid === currentPeer) updatePeerStatus(currentPeer)
  })

  signaling.on('broadcast', { event: 'signal' }, async ({ payload }) => {
    if (!payload || payload.to !== MY_ID) return
    if (payload.type === 'offer') await handleOffer(payload.from, payload.sdp)
    else if (payload.type === 'answer') await handleAnswer(payload.from, payload.sdp)
    else if (payload.type === 'candidate') await handleCandidate(payload.from, payload.candidate)
    else if (payload.type === 'message') appendIncoming(payload.from, payload.data, payload.isImage, payload.ts, payload.id)
    else if (payload.type === 'typing') {
  if (payload.from === currentPeer) showTyping(payload.from)
}
else if (payload.type === 'stopTyping') {
  hideTyping(payload.from)
}

  })

  await presence.subscribe()
  await signaling.subscribe()
  setInterval(() => sendPresence('update'), 25000)
  window.addEventListener('beforeunload', () => sendPresence('leave'))
  sendPresence('join')

  await fetchDriveData()
}

function sendPresence(action) {
  supabase.channel('presence').send({
    type: 'broadcast', event: 'presence',
    payload: { uuid: MY_ID, name: MY_NAME, avatar: MY_AVATAR, action, ts: Date.now() }
  })
}
function sendSignal(to, msg) {
  supabase.channel('signaling').send({
    type: 'broadcast', event: 'signal', payload: { ...msg, from: MY_ID, to }
  })
}

// ---- WebRTC ----
function createConnection(peer) {
  const pc = new RTCPeerConnection()
  const dc = pc.createDataChannel('chat')
  dc.onmessage = ev => {
    const d = JSON.parse(ev.data)
    appendIncoming(peer, d.text, d.isImage, d.ts, d.id)
  }
  dc.onopen = () => (dcMap[peer] = dc)
  pc.onicecandidate = e => e.candidate && sendSignal(peer, { type: 'candidate', candidate: e.candidate })
  pcMap[peer] = pc
  makeOffer(peer)
}
async function makeOffer(peer) {
  const pc = pcMap[peer]
  const offer = await pc.createOffer()
  await pc.setLocalDescription(offer)
  sendSignal(peer, { type: 'offer', sdp: offer })
}
async function handleOffer(from, sdp) {
  const pc = new RTCPeerConnection()
  pc.ondatachannel = e => {
    const ch = e.channel
    ch.onmessage = ev => {
      const d = JSON.parse(ev.data)
      appendIncoming(from, d.text, d.isImage, d.ts, d.id)
    }
    ch.onopen = () => (dcMap[from] = ch)
  }
  pc.onicecandidate = e => e.candidate && sendSignal(from, { type: 'candidate', candidate: e.candidate })
  pcMap[from] = pc
  await pc.setRemoteDescription(new RTCSessionDescription(sdp))
  const answer = await pc.createAnswer()
  await pc.setLocalDescription(answer)
  sendSignal(from, { type: 'answer', sdp: answer })
}
async function handleAnswer(from, sdp) {
  await pcMap[from]?.setRemoteDescription(new RTCSessionDescription(sdp))
}
async function handleCandidate(from, candidate) {
  await pcMap[from]?.addIceCandidate(new RTCIceCandidate(candidate))
}

// ---- Drive Persistence ----
async function fetchDriveData() {
  try {
    const listRes = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${DRIVE_FILE_NAME}' and trashed=false&fields=files(id,name)`, {
      headers: { Authorization: 'Bearer ' + DRIVE_TOKEN }
    })
    const list = await listRes.json()
    DRIVE_FILE_ID = list.files?.[0]?.id
    if (DRIVE_FILE_ID) {
      const fileRes = await fetch(`https://www.googleapis.com/drive/v3/files/${DRIVE_FILE_ID}?alt=media`, {
        headers: { Authorization: 'Bearer ' + DRIVE_TOKEN }
      })
      if (fileRes.ok) {
        chatStore = await fileRes.json()
        renderContacts()
      }
    } else saveToDrive()
  } catch (e) { logout() }
}
async function saveToDrive() {
  try {
    const meta = { name: DRIVE_FILE_NAME, mimeType: 'application/json' }
    const form = new FormData()
    form.append('metadata', new Blob([JSON.stringify(meta)], { type: 'application/json' }))
    form.append('file', new Blob([JSON.stringify(chatStore)], { type: 'application/json' }))
    const url = DRIVE_FILE_ID
      ? `https://www.googleapis.com/upload/drive/v3/files/${DRIVE_FILE_ID}?uploadType=multipart`
      : `https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart`
    const res = await fetch(url, { method: DRIVE_FILE_ID ? 'PATCH' : 'POST', headers: { Authorization: 'Bearer ' + DRIVE_TOKEN }, body: form })
    if (res.ok) DRIVE_FILE_ID = (await res.json()).id
  } catch { logout() }
}
function logout() { localStorage.removeItem(STORAGE_KEY); location.href = 'register.html' }

// ---- Status Updates ----
function updatePeerStatus(id) {
  peerStatusEl.textContent = online[id] ? 'Online' :
    chatStore[id]?.lastSeen ? 'Last seen at ' + new Date(chatStore[id].lastSeen).toLocaleTimeString() : 'Offline'
}

// ---- Init ----
searchEl.oninput = () => renderContacts(searchEl.value.trim())
addBtn.onclick = () => {
  renderOnlineDialog();
};

logoutBtn.onclick = logout
sendBtn.onclick = sendMessage
messageInput.onkeydown = e => {
  if (!currentPeer) return
  if (e.key === 'Enter') sendMessage()
  else sendTypingSignal()
}
function renderOnlineDialog() {
  const dialog = document.getElementById('onlineDialog');
  const list = document.getElementById('onlineList');
  const closeBtn = document.getElementById('closeDialog');
  list.innerHTML = '';

  const onlineUsers = Object.values(chatStore)
    .map(c => c.profile)
    .filter(p => online[p.uuid] && p.uuid !== MY_ID);

  if (onlineUsers.length === 0) {
    list.innerHTML = `<div style="text-align:center;color:#64748b;padding:20px">No one online</div>`;
  } else {
    for (const u of onlineUsers) {
      const div = document.createElement('div');
      div.className = 'dialog-user';
      div.innerHTML = `
        <img src="${u.avatar}">
        <span>${u.name}</span>
      `;
      div.onclick = () => {
        dialog.style.display = 'none';
        if (!chatStore[u.uuid])
          chatStore[u.uuid] = { profile: u, messages: [], unreadCount: 0 };
        openChat(u.uuid);
      };
      list.appendChild(div);
    }
  }

  dialog.style.display = 'flex';
  closeBtn.onclick = () => dialog.style.display = 'none';
}

function sendTypingSignal() {
  if (!currentPeer) return
  clearTimeout(typingTimeout[currentPeer])
  sendSignal(currentPeer, { type: 'typing' })
  typingTimeout[currentPeer] = setTimeout(() => {
    sendSignal(currentPeer, { type: 'stopTyping' })
  }, 3000)
}

startRealtime()
</script> 
</body>
</html>





